/* 
 * Defect Dojo API
 *
 * To use the API you need be authorized.
 *
 * OpenAPI spec version: v2
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp.Portable;
using DefectDojo.Client;
using DefectDojo.Model;

namespace DefectDojo.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IFindingsApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data"></param>
        /// <returns>RiskAcceptance</returns>
        RiskAcceptance FindingsAcceptRisks (List<AcceptedRisk> data);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data"></param>
        /// <returns>ApiResponse of RiskAcceptance</returns>
        ApiResponse<RiskAcceptance> FindingsAcceptRisksWithHttpInfo (List<AcceptedRisk> data);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data"></param>
        /// <returns>FindingCreate</returns>
        FindingCreate FindingsCreate (FindingCreate data);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data"></param>
        /// <returns>ApiResponse of FindingCreate</returns>
        ApiResponse<FindingCreate> FindingsCreateWithHttpInfo (FindingCreate data);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns></returns>
        void FindingsDelete (int? id);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> FindingsDeleteWithHttpInfo (int? id);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns></returns>
        void FindingsDuplicateResetFindingDuplicateStatus (int? id);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> FindingsDuplicateResetFindingDuplicateStatusWithHttpInfo (int? id);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>FindingToFiles</returns>
        FindingToFiles FindingsFilesCreate (int? id, AddNewFileOption data);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>ApiResponse of FindingToFiles</returns>
        ApiResponse<FindingToFiles> FindingsFilesCreateWithHttpInfo (int? id, AddNewFileOption data);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>FindingToFiles</returns>
        FindingToFiles FindingsFilesPartialUpdate (int? id, AddNewFileOption data);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>ApiResponse of FindingToFiles</returns>
        ApiResponse<FindingToFiles> FindingsFilesPartialUpdateWithHttpInfo (int? id, AddNewFileOption data);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>FindingToFiles</returns>
        FindingToFiles FindingsFilesRead (int? id);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>ApiResponse of FindingToFiles</returns>
        ApiResponse<FindingToFiles> FindingsFilesReadWithHttpInfo (int? id);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data"></param>
        /// <returns>ReportGenerate</returns>
        ReportGenerate FindingsGenerateReport (ReportGenerateOption data);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data"></param>
        /// <returns>ApiResponse of ReportGenerate</returns>
        ApiResponse<ReportGenerate> FindingsGenerateReportWithHttpInfo (ReportGenerateOption data);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>List&lt;Finding&gt;</returns>
        List<Finding> FindingsGetDuplicateStatus (int? id);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>ApiResponse of List&lt;Finding&gt;</returns>
        ApiResponse<List<Finding>> FindingsGetDuplicateStatusWithHttpInfo (int? id);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="title"> (optional)</param>
        /// <param name="date"> (optional)</param>
        /// <param name="slaStartDate"> (optional)</param>
        /// <param name="cwe">Multiple values may be separated by commas. (optional)</param>
        /// <param name="cve"> (optional)</param>
        /// <param name="cvssv3"> (optional)</param>
        /// <param name="cvssv3Score"> (optional)</param>
        /// <param name="severity"> (optional)</param>
        /// <param name="description"> (optional)</param>
        /// <param name="mitigation"> (optional)</param>
        /// <param name="impact"> (optional)</param>
        /// <param name="stepsToReproduce"> (optional)</param>
        /// <param name="severityJustification"> (optional)</param>
        /// <param name="endpoints">Multiple values may be separated by commas. (optional)</param>
        /// <param name="references"> (optional)</param>
        /// <param name="test"> (optional)</param>
        /// <param name="active"> (optional)</param>
        /// <param name="verified"> (optional)</param>
        /// <param name="falseP"> (optional)</param>
        /// <param name="duplicate"> (optional)</param>
        /// <param name="duplicateFinding"> (optional)</param>
        /// <param name="outOfScope"> (optional)</param>
        /// <param name="riskAccepted"> (optional)</param>
        /// <param name="underReview"> (optional)</param>
        /// <param name="lastStatusUpdate"> (optional)</param>
        /// <param name="reviewRequestedBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="reviewers">Multiple values may be separated by commas. (optional)</param>
        /// <param name="underDefectReview"> (optional)</param>
        /// <param name="defectReviewRequestedBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="isMitigated"> (optional)</param>
        /// <param name="mitigated"> (optional)</param>
        /// <param name="mitigatedBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="reporter">Multiple values may be separated by commas. (optional)</param>
        /// <param name="numericalSeverity"> (optional)</param>
        /// <param name="lastReviewed"> (optional)</param>
        /// <param name="lastReviewedBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="lineNumber"> (optional)</param>
        /// <param name="sourcefilepath"> (optional)</param>
        /// <param name="param"> (optional)</param>
        /// <param name="payload"> (optional)</param>
        /// <param name="hashCode"> (optional)</param>
        /// <param name="filePath"> (optional)</param>
        /// <param name="componentName"> (optional)</param>
        /// <param name="componentVersion"> (optional)</param>
        /// <param name="foundBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="staticFinding"> (optional)</param>
        /// <param name="dynamicFinding"> (optional)</param>
        /// <param name="created"> (optional)</param>
        /// <param name="scannerConfidence">Multiple values may be separated by commas. (optional)</param>
        /// <param name="sonarqubeIssue">Multiple values may be separated by commas. (optional)</param>
        /// <param name="uniqueIdFromTool"> (optional)</param>
        /// <param name="vulnIdFromTool"> (optional)</param>
        /// <param name="sastSourceObject"> (optional)</param>
        /// <param name="sastSinkObject"> (optional)</param>
        /// <param name="sastSourceLine">Multiple values may be separated by commas. (optional)</param>
        /// <param name="sastSourceFilePath"> (optional)</param>
        /// <param name="nbOccurences">Multiple values may be separated by commas. (optional)</param>
        /// <param name="publishDate"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="stepToReproduce"> (optional)</param>
        /// <param name="sourcefile"> (optional)</param>
        /// <param name="jiraCreation"> (optional)</param>
        /// <param name="jiraChange"> (optional)</param>
        /// <param name="id">Multiple values may be separated by commas. (optional)</param>
        /// <param name="testTestType">Multiple values may be separated by commas. (optional)</param>
        /// <param name="testEngagement">Multiple values may be separated by commas. (optional)</param>
        /// <param name="testEngagementProduct">Multiple values may be separated by commas. (optional)</param>
        /// <param name="findingGroup">Multiple values may be separated by commas. (optional)</param>
        /// <param name="riskAcceptance"> (optional)</param>
        /// <param name="tag"> (optional)</param>
        /// <param name="o"> (optional)</param>
        /// <param name="limit">Number of results to return per page. (optional)</param>
        /// <param name="offset">The initial index from which to return the results. (optional)</param>
        /// <param name="prefetch"> (optional)</param>
        /// <param name="relatedFields">Expand finding external relations (engagement, environment, product, product_type, test, test_type) (optional)</param>
        /// <returns>InlineResponse2005</returns>
        InlineResponse2005 FindingsList (string title = null, string date = null, string slaStartDate = null, decimal? cwe = null, string cve = null, string cvssv3 = null, decimal? cvssv3Score = null, string severity = null, string description = null, string mitigation = null, string impact = null, string stepsToReproduce = null, string severityJustification = null, decimal? endpoints = null, string references = null, string test = null, string active = null, string verified = null, string falseP = null, string duplicate = null, string duplicateFinding = null, string outOfScope = null, string riskAccepted = null, string underReview = null, string lastStatusUpdate = null, decimal? reviewRequestedBy = null, decimal? reviewers = null, string underDefectReview = null, decimal? defectReviewRequestedBy = null, string isMitigated = null, string mitigated = null, decimal? mitigatedBy = null, decimal? reporter = null, string numericalSeverity = null, string lastReviewed = null, decimal? lastReviewedBy = null, string lineNumber = null, string sourcefilepath = null, string param = null, string payload = null, string hashCode = null, string filePath = null, string componentName = null, string componentVersion = null, decimal? foundBy = null, string staticFinding = null, string dynamicFinding = null, string created = null, decimal? scannerConfidence = null, decimal? sonarqubeIssue = null, string uniqueIdFromTool = null, string vulnIdFromTool = null, string sastSourceObject = null, string sastSinkObject = null, decimal? sastSourceLine = null, string sastSourceFilePath = null, decimal? nbOccurences = null, string publishDate = null, string tags = null, string stepToReproduce = null, string sourcefile = null, string jiraCreation = null, string jiraChange = null, decimal? id = null, decimal? testTestType = null, decimal? testEngagement = null, decimal? testEngagementProduct = null, decimal? findingGroup = null, string riskAcceptance = null, string tag = null, string o = null, int? limit = null, int? offset = null, List<string> prefetch = null, bool? relatedFields = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="title"> (optional)</param>
        /// <param name="date"> (optional)</param>
        /// <param name="slaStartDate"> (optional)</param>
        /// <param name="cwe">Multiple values may be separated by commas. (optional)</param>
        /// <param name="cve"> (optional)</param>
        /// <param name="cvssv3"> (optional)</param>
        /// <param name="cvssv3Score"> (optional)</param>
        /// <param name="severity"> (optional)</param>
        /// <param name="description"> (optional)</param>
        /// <param name="mitigation"> (optional)</param>
        /// <param name="impact"> (optional)</param>
        /// <param name="stepsToReproduce"> (optional)</param>
        /// <param name="severityJustification"> (optional)</param>
        /// <param name="endpoints">Multiple values may be separated by commas. (optional)</param>
        /// <param name="references"> (optional)</param>
        /// <param name="test"> (optional)</param>
        /// <param name="active"> (optional)</param>
        /// <param name="verified"> (optional)</param>
        /// <param name="falseP"> (optional)</param>
        /// <param name="duplicate"> (optional)</param>
        /// <param name="duplicateFinding"> (optional)</param>
        /// <param name="outOfScope"> (optional)</param>
        /// <param name="riskAccepted"> (optional)</param>
        /// <param name="underReview"> (optional)</param>
        /// <param name="lastStatusUpdate"> (optional)</param>
        /// <param name="reviewRequestedBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="reviewers">Multiple values may be separated by commas. (optional)</param>
        /// <param name="underDefectReview"> (optional)</param>
        /// <param name="defectReviewRequestedBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="isMitigated"> (optional)</param>
        /// <param name="mitigated"> (optional)</param>
        /// <param name="mitigatedBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="reporter">Multiple values may be separated by commas. (optional)</param>
        /// <param name="numericalSeverity"> (optional)</param>
        /// <param name="lastReviewed"> (optional)</param>
        /// <param name="lastReviewedBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="lineNumber"> (optional)</param>
        /// <param name="sourcefilepath"> (optional)</param>
        /// <param name="param"> (optional)</param>
        /// <param name="payload"> (optional)</param>
        /// <param name="hashCode"> (optional)</param>
        /// <param name="filePath"> (optional)</param>
        /// <param name="componentName"> (optional)</param>
        /// <param name="componentVersion"> (optional)</param>
        /// <param name="foundBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="staticFinding"> (optional)</param>
        /// <param name="dynamicFinding"> (optional)</param>
        /// <param name="created"> (optional)</param>
        /// <param name="scannerConfidence">Multiple values may be separated by commas. (optional)</param>
        /// <param name="sonarqubeIssue">Multiple values may be separated by commas. (optional)</param>
        /// <param name="uniqueIdFromTool"> (optional)</param>
        /// <param name="vulnIdFromTool"> (optional)</param>
        /// <param name="sastSourceObject"> (optional)</param>
        /// <param name="sastSinkObject"> (optional)</param>
        /// <param name="sastSourceLine">Multiple values may be separated by commas. (optional)</param>
        /// <param name="sastSourceFilePath"> (optional)</param>
        /// <param name="nbOccurences">Multiple values may be separated by commas. (optional)</param>
        /// <param name="publishDate"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="stepToReproduce"> (optional)</param>
        /// <param name="sourcefile"> (optional)</param>
        /// <param name="jiraCreation"> (optional)</param>
        /// <param name="jiraChange"> (optional)</param>
        /// <param name="id">Multiple values may be separated by commas. (optional)</param>
        /// <param name="testTestType">Multiple values may be separated by commas. (optional)</param>
        /// <param name="testEngagement">Multiple values may be separated by commas. (optional)</param>
        /// <param name="testEngagementProduct">Multiple values may be separated by commas. (optional)</param>
        /// <param name="findingGroup">Multiple values may be separated by commas. (optional)</param>
        /// <param name="riskAcceptance"> (optional)</param>
        /// <param name="tag"> (optional)</param>
        /// <param name="o"> (optional)</param>
        /// <param name="limit">Number of results to return per page. (optional)</param>
        /// <param name="offset">The initial index from which to return the results. (optional)</param>
        /// <param name="prefetch"> (optional)</param>
        /// <param name="relatedFields">Expand finding external relations (engagement, environment, product, product_type, test, test_type) (optional)</param>
        /// <returns>ApiResponse of InlineResponse2005</returns>
        ApiResponse<InlineResponse2005> FindingsListWithHttpInfo (string title = null, string date = null, string slaStartDate = null, decimal? cwe = null, string cve = null, string cvssv3 = null, decimal? cvssv3Score = null, string severity = null, string description = null, string mitigation = null, string impact = null, string stepsToReproduce = null, string severityJustification = null, decimal? endpoints = null, string references = null, string test = null, string active = null, string verified = null, string falseP = null, string duplicate = null, string duplicateFinding = null, string outOfScope = null, string riskAccepted = null, string underReview = null, string lastStatusUpdate = null, decimal? reviewRequestedBy = null, decimal? reviewers = null, string underDefectReview = null, decimal? defectReviewRequestedBy = null, string isMitigated = null, string mitigated = null, decimal? mitigatedBy = null, decimal? reporter = null, string numericalSeverity = null, string lastReviewed = null, decimal? lastReviewedBy = null, string lineNumber = null, string sourcefilepath = null, string param = null, string payload = null, string hashCode = null, string filePath = null, string componentName = null, string componentVersion = null, decimal? foundBy = null, string staticFinding = null, string dynamicFinding = null, string created = null, decimal? scannerConfidence = null, decimal? sonarqubeIssue = null, string uniqueIdFromTool = null, string vulnIdFromTool = null, string sastSourceObject = null, string sastSinkObject = null, decimal? sastSourceLine = null, string sastSourceFilePath = null, decimal? nbOccurences = null, string publishDate = null, string tags = null, string stepToReproduce = null, string sourcefile = null, string jiraCreation = null, string jiraChange = null, decimal? id = null, decimal? testTestType = null, decimal? testEngagement = null, decimal? testEngagementProduct = null, decimal? findingGroup = null, string riskAcceptance = null, string tag = null, string o = null, int? limit = null, int? offset = null, List<string> prefetch = null, bool? relatedFields = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>FindingMeta</returns>
        FindingMeta FindingsMetadataCreate (int? id, FindingMeta data);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>ApiResponse of FindingMeta</returns>
        ApiResponse<FindingMeta> FindingsMetadataCreateWithHttpInfo (int? id, FindingMeta data);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="name">name of the metadata to retrieve. If name is empty, return all the                             metadata associated with the finding</param>
        /// <returns></returns>
        void FindingsMetadataDelete (int? id, string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="name">name of the metadata to retrieve. If name is empty, return all the                             metadata associated with the finding</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> FindingsMetadataDeleteWithHttpInfo (int? id, string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>List&lt;FindingMeta&gt;</returns>
        List<FindingMeta> FindingsMetadataRead (int? id);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>ApiResponse of List&lt;FindingMeta&gt;</returns>
        ApiResponse<List<FindingMeta>> FindingsMetadataReadWithHttpInfo (int? id);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <param name="name">name of the metadata to edit</param>
        /// <returns>FindingMeta</returns>
        FindingMeta FindingsMetadataUpdate (int? id, FindingMeta data, string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <param name="name">name of the metadata to edit</param>
        /// <returns>ApiResponse of FindingMeta</returns>
        ApiResponse<FindingMeta> FindingsMetadataUpdateWithHttpInfo (int? id, FindingMeta data, string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Note</returns>
        Note FindingsNotesCreate (int? id, AddNewNoteOption data);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>ApiResponse of Note</returns>
        ApiResponse<Note> FindingsNotesCreateWithHttpInfo (int? id, AddNewNoteOption data);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Note</returns>
        Note FindingsNotesPartialUpdate (int? id, AddNewNoteOption data);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>ApiResponse of Note</returns>
        ApiResponse<Note> FindingsNotesPartialUpdateWithHttpInfo (int? id, AddNewNoteOption data);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>FindingToNotes</returns>
        FindingToNotes FindingsNotesRead (int? id);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>ApiResponse of FindingToNotes</returns>
        ApiResponse<FindingToNotes> FindingsNotesReadWithHttpInfo (int? id);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Finding</returns>
        Finding FindingsPartialUpdate (int? id, Finding data);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>ApiResponse of Finding</returns>
        ApiResponse<Finding> FindingsPartialUpdateWithHttpInfo (int? id, Finding data);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="prefetch"> (optional)</param>
        /// <param name="relatedFields">Expand finding external relations (engagement, environment, product, product_type, test, test_type) (optional)</param>
        /// <returns>InlineResponse2006</returns>
        InlineResponse2006 FindingsRead (int? id, List<string> prefetch = null, bool? relatedFields = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="prefetch"> (optional)</param>
        /// <param name="relatedFields">Expand finding external relations (engagement, environment, product, product_type, test, test_type) (optional)</param>
        /// <returns>ApiResponse of InlineResponse2006</returns>
        ApiResponse<InlineResponse2006> FindingsReadWithHttpInfo (int? id, List<string> prefetch = null, bool? relatedFields = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Remove Note From Finding Note
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns></returns>
        void FindingsRemoveNote (int? id, FindingNote data);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Remove Note From Finding Note
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> FindingsRemoveNoteWithHttpInfo (int? id, FindingNote data);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Remove Tag(s) from finding list of tags
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns></returns>
        void FindingsRemoveTagsPartialUpdate (int? id, Tag data);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Remove Tag(s) from finding list of tags
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> FindingsRemoveTagsPartialUpdateWithHttpInfo (int? id, Tag data);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Remove Tag(s) from finding list of tags
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns></returns>
        void FindingsRemoveTagsUpdate (int? id, Tag data);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Remove Tag(s) from finding list of tags
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> FindingsRemoveTagsUpdateWithHttpInfo (int? id, Tag data);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>BurpRawRequestResponse</returns>
        BurpRawRequestResponse FindingsRequestResponseCreate (int? id, BurpRawRequestResponse data);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>ApiResponse of BurpRawRequestResponse</returns>
        ApiResponse<BurpRawRequestResponse> FindingsRequestResponseCreateWithHttpInfo (int? id, BurpRawRequestResponse data);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>BurpRawRequestResponse</returns>
        BurpRawRequestResponse FindingsRequestResponseRead (int? id);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>ApiResponse of BurpRawRequestResponse</returns>
        ApiResponse<BurpRawRequestResponse> FindingsRequestResponseReadWithHttpInfo (int? id);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="newFid"></param>
        /// <returns></returns>
        void FindingsSetFindingAsOriginal (int? id, string newFid);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="newFid"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> FindingsSetFindingAsOriginalWithHttpInfo (int? id, string newFid);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Tag</returns>
        Tag FindingsTagsCreate (int? id, Tag data);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>ApiResponse of Tag</returns>
        ApiResponse<Tag> FindingsTagsCreateWithHttpInfo (int? id, Tag data);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>Tag</returns>
        Tag FindingsTagsRead (int? id);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>ApiResponse of Tag</returns>
        ApiResponse<Tag> FindingsTagsReadWithHttpInfo (int? id);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Finding</returns>
        Finding FindingsUpdate (int? id, Finding data);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>ApiResponse of Finding</returns>
        ApiResponse<Finding> FindingsUpdateWithHttpInfo (int? id, Finding data);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data"></param>
        /// <returns>Task of RiskAcceptance</returns>
        System.Threading.Tasks.Task<RiskAcceptance> FindingsAcceptRisksAsync (List<AcceptedRisk> data);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data"></param>
        /// <returns>Task of ApiResponse (RiskAcceptance)</returns>
        System.Threading.Tasks.Task<ApiResponse<RiskAcceptance>> FindingsAcceptRisksAsyncWithHttpInfo (List<AcceptedRisk> data);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data"></param>
        /// <returns>Task of FindingCreate</returns>
        System.Threading.Tasks.Task<FindingCreate> FindingsCreateAsync (FindingCreate data);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data"></param>
        /// <returns>Task of ApiResponse (FindingCreate)</returns>
        System.Threading.Tasks.Task<ApiResponse<FindingCreate>> FindingsCreateAsyncWithHttpInfo (FindingCreate data);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task FindingsDeleteAsync (int? id);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> FindingsDeleteAsyncWithHttpInfo (int? id);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task FindingsDuplicateResetFindingDuplicateStatusAsync (int? id);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> FindingsDuplicateResetFindingDuplicateStatusAsyncWithHttpInfo (int? id);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of FindingToFiles</returns>
        System.Threading.Tasks.Task<FindingToFiles> FindingsFilesCreateAsync (int? id, AddNewFileOption data);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of ApiResponse (FindingToFiles)</returns>
        System.Threading.Tasks.Task<ApiResponse<FindingToFiles>> FindingsFilesCreateAsyncWithHttpInfo (int? id, AddNewFileOption data);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of FindingToFiles</returns>
        System.Threading.Tasks.Task<FindingToFiles> FindingsFilesPartialUpdateAsync (int? id, AddNewFileOption data);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of ApiResponse (FindingToFiles)</returns>
        System.Threading.Tasks.Task<ApiResponse<FindingToFiles>> FindingsFilesPartialUpdateAsyncWithHttpInfo (int? id, AddNewFileOption data);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>Task of FindingToFiles</returns>
        System.Threading.Tasks.Task<FindingToFiles> FindingsFilesReadAsync (int? id);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>Task of ApiResponse (FindingToFiles)</returns>
        System.Threading.Tasks.Task<ApiResponse<FindingToFiles>> FindingsFilesReadAsyncWithHttpInfo (int? id);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data"></param>
        /// <returns>Task of ReportGenerate</returns>
        System.Threading.Tasks.Task<ReportGenerate> FindingsGenerateReportAsync (ReportGenerateOption data);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data"></param>
        /// <returns>Task of ApiResponse (ReportGenerate)</returns>
        System.Threading.Tasks.Task<ApiResponse<ReportGenerate>> FindingsGenerateReportAsyncWithHttpInfo (ReportGenerateOption data);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>Task of List&lt;Finding&gt;</returns>
        System.Threading.Tasks.Task<List<Finding>> FindingsGetDuplicateStatusAsync (int? id);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>Task of ApiResponse (List&lt;Finding&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<Finding>>> FindingsGetDuplicateStatusAsyncWithHttpInfo (int? id);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="title"> (optional)</param>
        /// <param name="date"> (optional)</param>
        /// <param name="slaStartDate"> (optional)</param>
        /// <param name="cwe">Multiple values may be separated by commas. (optional)</param>
        /// <param name="cve"> (optional)</param>
        /// <param name="cvssv3"> (optional)</param>
        /// <param name="cvssv3Score"> (optional)</param>
        /// <param name="severity"> (optional)</param>
        /// <param name="description"> (optional)</param>
        /// <param name="mitigation"> (optional)</param>
        /// <param name="impact"> (optional)</param>
        /// <param name="stepsToReproduce"> (optional)</param>
        /// <param name="severityJustification"> (optional)</param>
        /// <param name="endpoints">Multiple values may be separated by commas. (optional)</param>
        /// <param name="references"> (optional)</param>
        /// <param name="test"> (optional)</param>
        /// <param name="active"> (optional)</param>
        /// <param name="verified"> (optional)</param>
        /// <param name="falseP"> (optional)</param>
        /// <param name="duplicate"> (optional)</param>
        /// <param name="duplicateFinding"> (optional)</param>
        /// <param name="outOfScope"> (optional)</param>
        /// <param name="riskAccepted"> (optional)</param>
        /// <param name="underReview"> (optional)</param>
        /// <param name="lastStatusUpdate"> (optional)</param>
        /// <param name="reviewRequestedBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="reviewers">Multiple values may be separated by commas. (optional)</param>
        /// <param name="underDefectReview"> (optional)</param>
        /// <param name="defectReviewRequestedBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="isMitigated"> (optional)</param>
        /// <param name="mitigated"> (optional)</param>
        /// <param name="mitigatedBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="reporter">Multiple values may be separated by commas. (optional)</param>
        /// <param name="numericalSeverity"> (optional)</param>
        /// <param name="lastReviewed"> (optional)</param>
        /// <param name="lastReviewedBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="lineNumber"> (optional)</param>
        /// <param name="sourcefilepath"> (optional)</param>
        /// <param name="param"> (optional)</param>
        /// <param name="payload"> (optional)</param>
        /// <param name="hashCode"> (optional)</param>
        /// <param name="filePath"> (optional)</param>
        /// <param name="componentName"> (optional)</param>
        /// <param name="componentVersion"> (optional)</param>
        /// <param name="foundBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="staticFinding"> (optional)</param>
        /// <param name="dynamicFinding"> (optional)</param>
        /// <param name="created"> (optional)</param>
        /// <param name="scannerConfidence">Multiple values may be separated by commas. (optional)</param>
        /// <param name="sonarqubeIssue">Multiple values may be separated by commas. (optional)</param>
        /// <param name="uniqueIdFromTool"> (optional)</param>
        /// <param name="vulnIdFromTool"> (optional)</param>
        /// <param name="sastSourceObject"> (optional)</param>
        /// <param name="sastSinkObject"> (optional)</param>
        /// <param name="sastSourceLine">Multiple values may be separated by commas. (optional)</param>
        /// <param name="sastSourceFilePath"> (optional)</param>
        /// <param name="nbOccurences">Multiple values may be separated by commas. (optional)</param>
        /// <param name="publishDate"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="stepToReproduce"> (optional)</param>
        /// <param name="sourcefile"> (optional)</param>
        /// <param name="jiraCreation"> (optional)</param>
        /// <param name="jiraChange"> (optional)</param>
        /// <param name="id">Multiple values may be separated by commas. (optional)</param>
        /// <param name="testTestType">Multiple values may be separated by commas. (optional)</param>
        /// <param name="testEngagement">Multiple values may be separated by commas. (optional)</param>
        /// <param name="testEngagementProduct">Multiple values may be separated by commas. (optional)</param>
        /// <param name="findingGroup">Multiple values may be separated by commas. (optional)</param>
        /// <param name="riskAcceptance"> (optional)</param>
        /// <param name="tag"> (optional)</param>
        /// <param name="o"> (optional)</param>
        /// <param name="limit">Number of results to return per page. (optional)</param>
        /// <param name="offset">The initial index from which to return the results. (optional)</param>
        /// <param name="prefetch"> (optional)</param>
        /// <param name="relatedFields">Expand finding external relations (engagement, environment, product, product_type, test, test_type) (optional)</param>
        /// <returns>Task of InlineResponse2005</returns>
        System.Threading.Tasks.Task<InlineResponse2005> FindingsListAsync (string title = null, string date = null, string slaStartDate = null, decimal? cwe = null, string cve = null, string cvssv3 = null, decimal? cvssv3Score = null, string severity = null, string description = null, string mitigation = null, string impact = null, string stepsToReproduce = null, string severityJustification = null, decimal? endpoints = null, string references = null, string test = null, string active = null, string verified = null, string falseP = null, string duplicate = null, string duplicateFinding = null, string outOfScope = null, string riskAccepted = null, string underReview = null, string lastStatusUpdate = null, decimal? reviewRequestedBy = null, decimal? reviewers = null, string underDefectReview = null, decimal? defectReviewRequestedBy = null, string isMitigated = null, string mitigated = null, decimal? mitigatedBy = null, decimal? reporter = null, string numericalSeverity = null, string lastReviewed = null, decimal? lastReviewedBy = null, string lineNumber = null, string sourcefilepath = null, string param = null, string payload = null, string hashCode = null, string filePath = null, string componentName = null, string componentVersion = null, decimal? foundBy = null, string staticFinding = null, string dynamicFinding = null, string created = null, decimal? scannerConfidence = null, decimal? sonarqubeIssue = null, string uniqueIdFromTool = null, string vulnIdFromTool = null, string sastSourceObject = null, string sastSinkObject = null, decimal? sastSourceLine = null, string sastSourceFilePath = null, decimal? nbOccurences = null, string publishDate = null, string tags = null, string stepToReproduce = null, string sourcefile = null, string jiraCreation = null, string jiraChange = null, decimal? id = null, decimal? testTestType = null, decimal? testEngagement = null, decimal? testEngagementProduct = null, decimal? findingGroup = null, string riskAcceptance = null, string tag = null, string o = null, int? limit = null, int? offset = null, List<string> prefetch = null, bool? relatedFields = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="title"> (optional)</param>
        /// <param name="date"> (optional)</param>
        /// <param name="slaStartDate"> (optional)</param>
        /// <param name="cwe">Multiple values may be separated by commas. (optional)</param>
        /// <param name="cve"> (optional)</param>
        /// <param name="cvssv3"> (optional)</param>
        /// <param name="cvssv3Score"> (optional)</param>
        /// <param name="severity"> (optional)</param>
        /// <param name="description"> (optional)</param>
        /// <param name="mitigation"> (optional)</param>
        /// <param name="impact"> (optional)</param>
        /// <param name="stepsToReproduce"> (optional)</param>
        /// <param name="severityJustification"> (optional)</param>
        /// <param name="endpoints">Multiple values may be separated by commas. (optional)</param>
        /// <param name="references"> (optional)</param>
        /// <param name="test"> (optional)</param>
        /// <param name="active"> (optional)</param>
        /// <param name="verified"> (optional)</param>
        /// <param name="falseP"> (optional)</param>
        /// <param name="duplicate"> (optional)</param>
        /// <param name="duplicateFinding"> (optional)</param>
        /// <param name="outOfScope"> (optional)</param>
        /// <param name="riskAccepted"> (optional)</param>
        /// <param name="underReview"> (optional)</param>
        /// <param name="lastStatusUpdate"> (optional)</param>
        /// <param name="reviewRequestedBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="reviewers">Multiple values may be separated by commas. (optional)</param>
        /// <param name="underDefectReview"> (optional)</param>
        /// <param name="defectReviewRequestedBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="isMitigated"> (optional)</param>
        /// <param name="mitigated"> (optional)</param>
        /// <param name="mitigatedBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="reporter">Multiple values may be separated by commas. (optional)</param>
        /// <param name="numericalSeverity"> (optional)</param>
        /// <param name="lastReviewed"> (optional)</param>
        /// <param name="lastReviewedBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="lineNumber"> (optional)</param>
        /// <param name="sourcefilepath"> (optional)</param>
        /// <param name="param"> (optional)</param>
        /// <param name="payload"> (optional)</param>
        /// <param name="hashCode"> (optional)</param>
        /// <param name="filePath"> (optional)</param>
        /// <param name="componentName"> (optional)</param>
        /// <param name="componentVersion"> (optional)</param>
        /// <param name="foundBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="staticFinding"> (optional)</param>
        /// <param name="dynamicFinding"> (optional)</param>
        /// <param name="created"> (optional)</param>
        /// <param name="scannerConfidence">Multiple values may be separated by commas. (optional)</param>
        /// <param name="sonarqubeIssue">Multiple values may be separated by commas. (optional)</param>
        /// <param name="uniqueIdFromTool"> (optional)</param>
        /// <param name="vulnIdFromTool"> (optional)</param>
        /// <param name="sastSourceObject"> (optional)</param>
        /// <param name="sastSinkObject"> (optional)</param>
        /// <param name="sastSourceLine">Multiple values may be separated by commas. (optional)</param>
        /// <param name="sastSourceFilePath"> (optional)</param>
        /// <param name="nbOccurences">Multiple values may be separated by commas. (optional)</param>
        /// <param name="publishDate"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="stepToReproduce"> (optional)</param>
        /// <param name="sourcefile"> (optional)</param>
        /// <param name="jiraCreation"> (optional)</param>
        /// <param name="jiraChange"> (optional)</param>
        /// <param name="id">Multiple values may be separated by commas. (optional)</param>
        /// <param name="testTestType">Multiple values may be separated by commas. (optional)</param>
        /// <param name="testEngagement">Multiple values may be separated by commas. (optional)</param>
        /// <param name="testEngagementProduct">Multiple values may be separated by commas. (optional)</param>
        /// <param name="findingGroup">Multiple values may be separated by commas. (optional)</param>
        /// <param name="riskAcceptance"> (optional)</param>
        /// <param name="tag"> (optional)</param>
        /// <param name="o"> (optional)</param>
        /// <param name="limit">Number of results to return per page. (optional)</param>
        /// <param name="offset">The initial index from which to return the results. (optional)</param>
        /// <param name="prefetch"> (optional)</param>
        /// <param name="relatedFields">Expand finding external relations (engagement, environment, product, product_type, test, test_type) (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2005)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse2005>> FindingsListAsyncWithHttpInfo (string title = null, string date = null, string slaStartDate = null, decimal? cwe = null, string cve = null, string cvssv3 = null, decimal? cvssv3Score = null, string severity = null, string description = null, string mitigation = null, string impact = null, string stepsToReproduce = null, string severityJustification = null, decimal? endpoints = null, string references = null, string test = null, string active = null, string verified = null, string falseP = null, string duplicate = null, string duplicateFinding = null, string outOfScope = null, string riskAccepted = null, string underReview = null, string lastStatusUpdate = null, decimal? reviewRequestedBy = null, decimal? reviewers = null, string underDefectReview = null, decimal? defectReviewRequestedBy = null, string isMitigated = null, string mitigated = null, decimal? mitigatedBy = null, decimal? reporter = null, string numericalSeverity = null, string lastReviewed = null, decimal? lastReviewedBy = null, string lineNumber = null, string sourcefilepath = null, string param = null, string payload = null, string hashCode = null, string filePath = null, string componentName = null, string componentVersion = null, decimal? foundBy = null, string staticFinding = null, string dynamicFinding = null, string created = null, decimal? scannerConfidence = null, decimal? sonarqubeIssue = null, string uniqueIdFromTool = null, string vulnIdFromTool = null, string sastSourceObject = null, string sastSinkObject = null, decimal? sastSourceLine = null, string sastSourceFilePath = null, decimal? nbOccurences = null, string publishDate = null, string tags = null, string stepToReproduce = null, string sourcefile = null, string jiraCreation = null, string jiraChange = null, decimal? id = null, decimal? testTestType = null, decimal? testEngagement = null, decimal? testEngagementProduct = null, decimal? findingGroup = null, string riskAcceptance = null, string tag = null, string o = null, int? limit = null, int? offset = null, List<string> prefetch = null, bool? relatedFields = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of FindingMeta</returns>
        System.Threading.Tasks.Task<FindingMeta> FindingsMetadataCreateAsync (int? id, FindingMeta data);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of ApiResponse (FindingMeta)</returns>
        System.Threading.Tasks.Task<ApiResponse<FindingMeta>> FindingsMetadataCreateAsyncWithHttpInfo (int? id, FindingMeta data);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="name">name of the metadata to retrieve. If name is empty, return all the                             metadata associated with the finding</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task FindingsMetadataDeleteAsync (int? id, string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="name">name of the metadata to retrieve. If name is empty, return all the                             metadata associated with the finding</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> FindingsMetadataDeleteAsyncWithHttpInfo (int? id, string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>Task of List&lt;FindingMeta&gt;</returns>
        System.Threading.Tasks.Task<List<FindingMeta>> FindingsMetadataReadAsync (int? id);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>Task of ApiResponse (List&lt;FindingMeta&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<FindingMeta>>> FindingsMetadataReadAsyncWithHttpInfo (int? id);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <param name="name">name of the metadata to edit</param>
        /// <returns>Task of FindingMeta</returns>
        System.Threading.Tasks.Task<FindingMeta> FindingsMetadataUpdateAsync (int? id, FindingMeta data, string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <param name="name">name of the metadata to edit</param>
        /// <returns>Task of ApiResponse (FindingMeta)</returns>
        System.Threading.Tasks.Task<ApiResponse<FindingMeta>> FindingsMetadataUpdateAsyncWithHttpInfo (int? id, FindingMeta data, string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of Note</returns>
        System.Threading.Tasks.Task<Note> FindingsNotesCreateAsync (int? id, AddNewNoteOption data);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of ApiResponse (Note)</returns>
        System.Threading.Tasks.Task<ApiResponse<Note>> FindingsNotesCreateAsyncWithHttpInfo (int? id, AddNewNoteOption data);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of Note</returns>
        System.Threading.Tasks.Task<Note> FindingsNotesPartialUpdateAsync (int? id, AddNewNoteOption data);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of ApiResponse (Note)</returns>
        System.Threading.Tasks.Task<ApiResponse<Note>> FindingsNotesPartialUpdateAsyncWithHttpInfo (int? id, AddNewNoteOption data);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>Task of FindingToNotes</returns>
        System.Threading.Tasks.Task<FindingToNotes> FindingsNotesReadAsync (int? id);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>Task of ApiResponse (FindingToNotes)</returns>
        System.Threading.Tasks.Task<ApiResponse<FindingToNotes>> FindingsNotesReadAsyncWithHttpInfo (int? id);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of Finding</returns>
        System.Threading.Tasks.Task<Finding> FindingsPartialUpdateAsync (int? id, Finding data);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of ApiResponse (Finding)</returns>
        System.Threading.Tasks.Task<ApiResponse<Finding>> FindingsPartialUpdateAsyncWithHttpInfo (int? id, Finding data);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="prefetch"> (optional)</param>
        /// <param name="relatedFields">Expand finding external relations (engagement, environment, product, product_type, test, test_type) (optional)</param>
        /// <returns>Task of InlineResponse2006</returns>
        System.Threading.Tasks.Task<InlineResponse2006> FindingsReadAsync (int? id, List<string> prefetch = null, bool? relatedFields = null);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="prefetch"> (optional)</param>
        /// <param name="relatedFields">Expand finding external relations (engagement, environment, product, product_type, test, test_type) (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2006)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse2006>> FindingsReadAsyncWithHttpInfo (int? id, List<string> prefetch = null, bool? relatedFields = null);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Remove Note From Finding Note
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task FindingsRemoveNoteAsync (int? id, FindingNote data);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Remove Note From Finding Note
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> FindingsRemoveNoteAsyncWithHttpInfo (int? id, FindingNote data);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Remove Tag(s) from finding list of tags
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task FindingsRemoveTagsPartialUpdateAsync (int? id, Tag data);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Remove Tag(s) from finding list of tags
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> FindingsRemoveTagsPartialUpdateAsyncWithHttpInfo (int? id, Tag data);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Remove Tag(s) from finding list of tags
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task FindingsRemoveTagsUpdateAsync (int? id, Tag data);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Remove Tag(s) from finding list of tags
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> FindingsRemoveTagsUpdateAsyncWithHttpInfo (int? id, Tag data);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of BurpRawRequestResponse</returns>
        System.Threading.Tasks.Task<BurpRawRequestResponse> FindingsRequestResponseCreateAsync (int? id, BurpRawRequestResponse data);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of ApiResponse (BurpRawRequestResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<BurpRawRequestResponse>> FindingsRequestResponseCreateAsyncWithHttpInfo (int? id, BurpRawRequestResponse data);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>Task of BurpRawRequestResponse</returns>
        System.Threading.Tasks.Task<BurpRawRequestResponse> FindingsRequestResponseReadAsync (int? id);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>Task of ApiResponse (BurpRawRequestResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<BurpRawRequestResponse>> FindingsRequestResponseReadAsyncWithHttpInfo (int? id);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="newFid"></param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task FindingsSetFindingAsOriginalAsync (int? id, string newFid);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="newFid"></param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> FindingsSetFindingAsOriginalAsyncWithHttpInfo (int? id, string newFid);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of Tag</returns>
        System.Threading.Tasks.Task<Tag> FindingsTagsCreateAsync (int? id, Tag data);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of ApiResponse (Tag)</returns>
        System.Threading.Tasks.Task<ApiResponse<Tag>> FindingsTagsCreateAsyncWithHttpInfo (int? id, Tag data);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>Task of Tag</returns>
        System.Threading.Tasks.Task<Tag> FindingsTagsReadAsync (int? id);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>Task of ApiResponse (Tag)</returns>
        System.Threading.Tasks.Task<ApiResponse<Tag>> FindingsTagsReadAsyncWithHttpInfo (int? id);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of Finding</returns>
        System.Threading.Tasks.Task<Finding> FindingsUpdateAsync (int? id, Finding data);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of ApiResponse (Finding)</returns>
        System.Threading.Tasks.Task<ApiResponse<Finding>> FindingsUpdateAsyncWithHttpInfo (int? id, Finding data);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class FindingsApi : IFindingsApi
    {
        private DefectDojo.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="FindingsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public FindingsApi(String basePath)
        {
            this.Configuration = new DefectDojo.Client.Configuration { BasePath = basePath };

            ExceptionFactory = DefectDojo.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="FindingsApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public FindingsApi(DefectDojo.Client.Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = DefectDojo.Client.Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = DefectDojo.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public DefectDojo.Client.Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public DefectDojo.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data"></param>
        /// <returns>RiskAcceptance</returns>
        public RiskAcceptance FindingsAcceptRisks (List<AcceptedRisk> data)
        {
             ApiResponse<RiskAcceptance> localVarResponse = FindingsAcceptRisksWithHttpInfo(data);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data"></param>
        /// <returns>ApiResponse of RiskAcceptance</returns>
        public ApiResponse< RiskAcceptance > FindingsAcceptRisksWithHttpInfo (List<AcceptedRisk> data)
        {
            // verify the required parameter 'data' is set
            if (data == null)
                throw new ApiException(400, "Missing required parameter 'data' when calling FindingsApi->FindingsAcceptRisks");

            var localVarPath = "./findings/accept_risks/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (data != null && data.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(data); // http body (model) parameter
            }
            else
            {
                localVarPostBody = data; // byte array
            }

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsAcceptRisks", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<RiskAcceptance>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (RiskAcceptance) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(RiskAcceptance)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data"></param>
        /// <returns>Task of RiskAcceptance</returns>
        public async System.Threading.Tasks.Task<RiskAcceptance> FindingsAcceptRisksAsync (List<AcceptedRisk> data)
        {
             ApiResponse<RiskAcceptance> localVarResponse = await FindingsAcceptRisksAsyncWithHttpInfo(data);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data"></param>
        /// <returns>Task of ApiResponse (RiskAcceptance)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<RiskAcceptance>> FindingsAcceptRisksAsyncWithHttpInfo (List<AcceptedRisk> data)
        {
            // verify the required parameter 'data' is set
            if (data == null)
                throw new ApiException(400, "Missing required parameter 'data' when calling FindingsApi->FindingsAcceptRisks");

            var localVarPath = "./findings/accept_risks/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (data != null && data.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(data); // http body (model) parameter
            }
            else
            {
                localVarPostBody = data; // byte array
            }

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsAcceptRisks", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<RiskAcceptance>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (RiskAcceptance) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(RiskAcceptance)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data"></param>
        /// <returns>FindingCreate</returns>
        public FindingCreate FindingsCreate (FindingCreate data)
        {
             ApiResponse<FindingCreate> localVarResponse = FindingsCreateWithHttpInfo(data);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data"></param>
        /// <returns>ApiResponse of FindingCreate</returns>
        public ApiResponse< FindingCreate > FindingsCreateWithHttpInfo (FindingCreate data)
        {
            // verify the required parameter 'data' is set
            if (data == null)
                throw new ApiException(400, "Missing required parameter 'data' when calling FindingsApi->FindingsCreate");

            var localVarPath = "./findings/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (data != null && data.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(data); // http body (model) parameter
            }
            else
            {
                localVarPostBody = data; // byte array
            }

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsCreate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<FindingCreate>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (FindingCreate) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(FindingCreate)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data"></param>
        /// <returns>Task of FindingCreate</returns>
        public async System.Threading.Tasks.Task<FindingCreate> FindingsCreateAsync (FindingCreate data)
        {
             ApiResponse<FindingCreate> localVarResponse = await FindingsCreateAsyncWithHttpInfo(data);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data"></param>
        /// <returns>Task of ApiResponse (FindingCreate)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<FindingCreate>> FindingsCreateAsyncWithHttpInfo (FindingCreate data)
        {
            // verify the required parameter 'data' is set
            if (data == null)
                throw new ApiException(400, "Missing required parameter 'data' when calling FindingsApi->FindingsCreate");

            var localVarPath = "./findings/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (data != null && data.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(data); // http body (model) parameter
            }
            else
            {
                localVarPostBody = data; // byte array
            }

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsCreate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<FindingCreate>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (FindingCreate) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(FindingCreate)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns></returns>
        public void FindingsDelete (int? id)
        {
             FindingsDeleteWithHttpInfo(id);
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> FindingsDeleteWithHttpInfo (int? id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsDelete");

            var localVarPath = "./findings/{id}/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsDelete", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task FindingsDeleteAsync (int? id)
        {
             await FindingsDeleteAsyncWithHttpInfo(id);

        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> FindingsDeleteAsyncWithHttpInfo (int? id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsDelete");

            var localVarPath = "./findings/{id}/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsDelete", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns></returns>
        public void FindingsDuplicateResetFindingDuplicateStatus (int? id)
        {
             FindingsDuplicateResetFindingDuplicateStatusWithHttpInfo(id);
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> FindingsDuplicateResetFindingDuplicateStatusWithHttpInfo (int? id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsDuplicateResetFindingDuplicateStatus");

            var localVarPath = "./findings/{id}/duplicate/reset/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsDuplicateResetFindingDuplicateStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task FindingsDuplicateResetFindingDuplicateStatusAsync (int? id)
        {
             await FindingsDuplicateResetFindingDuplicateStatusAsyncWithHttpInfo(id);

        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> FindingsDuplicateResetFindingDuplicateStatusAsyncWithHttpInfo (int? id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsDuplicateResetFindingDuplicateStatus");

            var localVarPath = "./findings/{id}/duplicate/reset/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsDuplicateResetFindingDuplicateStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>FindingToFiles</returns>
        public FindingToFiles FindingsFilesCreate (int? id, AddNewFileOption data)
        {
             ApiResponse<FindingToFiles> localVarResponse = FindingsFilesCreateWithHttpInfo(id, data);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>ApiResponse of FindingToFiles</returns>
        public ApiResponse< FindingToFiles > FindingsFilesCreateWithHttpInfo (int? id, AddNewFileOption data)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsFilesCreate");
            // verify the required parameter 'data' is set
            if (data == null)
                throw new ApiException(400, "Missing required parameter 'data' when calling FindingsApi->FindingsFilesCreate");

            var localVarPath = "./findings/{id}/files/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (data != null && data.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(data); // http body (model) parameter
            }
            else
            {
                localVarPostBody = data; // byte array
            }

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsFilesCreate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<FindingToFiles>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (FindingToFiles) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(FindingToFiles)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of FindingToFiles</returns>
        public async System.Threading.Tasks.Task<FindingToFiles> FindingsFilesCreateAsync (int? id, AddNewFileOption data)
        {
             ApiResponse<FindingToFiles> localVarResponse = await FindingsFilesCreateAsyncWithHttpInfo(id, data);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of ApiResponse (FindingToFiles)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<FindingToFiles>> FindingsFilesCreateAsyncWithHttpInfo (int? id, AddNewFileOption data)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsFilesCreate");
            // verify the required parameter 'data' is set
            if (data == null)
                throw new ApiException(400, "Missing required parameter 'data' when calling FindingsApi->FindingsFilesCreate");

            var localVarPath = "./findings/{id}/files/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (data != null && data.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(data); // http body (model) parameter
            }
            else
            {
                localVarPostBody = data; // byte array
            }

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsFilesCreate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<FindingToFiles>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (FindingToFiles) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(FindingToFiles)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>FindingToFiles</returns>
        public FindingToFiles FindingsFilesPartialUpdate (int? id, AddNewFileOption data)
        {
             ApiResponse<FindingToFiles> localVarResponse = FindingsFilesPartialUpdateWithHttpInfo(id, data);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>ApiResponse of FindingToFiles</returns>
        public ApiResponse< FindingToFiles > FindingsFilesPartialUpdateWithHttpInfo (int? id, AddNewFileOption data)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsFilesPartialUpdate");
            // verify the required parameter 'data' is set
            if (data == null)
                throw new ApiException(400, "Missing required parameter 'data' when calling FindingsApi->FindingsFilesPartialUpdate");

            var localVarPath = "./findings/{id}/files/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (data != null && data.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(data); // http body (model) parameter
            }
            else
            {
                localVarPostBody = data; // byte array
            }

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsFilesPartialUpdate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<FindingToFiles>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (FindingToFiles) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(FindingToFiles)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of FindingToFiles</returns>
        public async System.Threading.Tasks.Task<FindingToFiles> FindingsFilesPartialUpdateAsync (int? id, AddNewFileOption data)
        {
             ApiResponse<FindingToFiles> localVarResponse = await FindingsFilesPartialUpdateAsyncWithHttpInfo(id, data);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of ApiResponse (FindingToFiles)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<FindingToFiles>> FindingsFilesPartialUpdateAsyncWithHttpInfo (int? id, AddNewFileOption data)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsFilesPartialUpdate");
            // verify the required parameter 'data' is set
            if (data == null)
                throw new ApiException(400, "Missing required parameter 'data' when calling FindingsApi->FindingsFilesPartialUpdate");

            var localVarPath = "./findings/{id}/files/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (data != null && data.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(data); // http body (model) parameter
            }
            else
            {
                localVarPostBody = data; // byte array
            }

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsFilesPartialUpdate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<FindingToFiles>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (FindingToFiles) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(FindingToFiles)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>FindingToFiles</returns>
        public FindingToFiles FindingsFilesRead (int? id)
        {
             ApiResponse<FindingToFiles> localVarResponse = FindingsFilesReadWithHttpInfo(id);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>ApiResponse of FindingToFiles</returns>
        public ApiResponse< FindingToFiles > FindingsFilesReadWithHttpInfo (int? id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsFilesRead");

            var localVarPath = "./findings/{id}/files/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsFilesRead", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<FindingToFiles>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (FindingToFiles) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(FindingToFiles)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>Task of FindingToFiles</returns>
        public async System.Threading.Tasks.Task<FindingToFiles> FindingsFilesReadAsync (int? id)
        {
             ApiResponse<FindingToFiles> localVarResponse = await FindingsFilesReadAsyncWithHttpInfo(id);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>Task of ApiResponse (FindingToFiles)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<FindingToFiles>> FindingsFilesReadAsyncWithHttpInfo (int? id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsFilesRead");

            var localVarPath = "./findings/{id}/files/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsFilesRead", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<FindingToFiles>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (FindingToFiles) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(FindingToFiles)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data"></param>
        /// <returns>ReportGenerate</returns>
        public ReportGenerate FindingsGenerateReport (ReportGenerateOption data)
        {
             ApiResponse<ReportGenerate> localVarResponse = FindingsGenerateReportWithHttpInfo(data);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data"></param>
        /// <returns>ApiResponse of ReportGenerate</returns>
        public ApiResponse< ReportGenerate > FindingsGenerateReportWithHttpInfo (ReportGenerateOption data)
        {
            // verify the required parameter 'data' is set
            if (data == null)
                throw new ApiException(400, "Missing required parameter 'data' when calling FindingsApi->FindingsGenerateReport");

            var localVarPath = "./findings/generate_report/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (data != null && data.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(data); // http body (model) parameter
            }
            else
            {
                localVarPostBody = data; // byte array
            }

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsGenerateReport", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ReportGenerate>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (ReportGenerate) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ReportGenerate)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data"></param>
        /// <returns>Task of ReportGenerate</returns>
        public async System.Threading.Tasks.Task<ReportGenerate> FindingsGenerateReportAsync (ReportGenerateOption data)
        {
             ApiResponse<ReportGenerate> localVarResponse = await FindingsGenerateReportAsyncWithHttpInfo(data);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data"></param>
        /// <returns>Task of ApiResponse (ReportGenerate)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ReportGenerate>> FindingsGenerateReportAsyncWithHttpInfo (ReportGenerateOption data)
        {
            // verify the required parameter 'data' is set
            if (data == null)
                throw new ApiException(400, "Missing required parameter 'data' when calling FindingsApi->FindingsGenerateReport");

            var localVarPath = "./findings/generate_report/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (data != null && data.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(data); // http body (model) parameter
            }
            else
            {
                localVarPostBody = data; // byte array
            }

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsGenerateReport", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ReportGenerate>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (ReportGenerate) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ReportGenerate)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>List&lt;Finding&gt;</returns>
        public List<Finding> FindingsGetDuplicateStatus (int? id)
        {
             ApiResponse<List<Finding>> localVarResponse = FindingsGetDuplicateStatusWithHttpInfo(id);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>ApiResponse of List&lt;Finding&gt;</returns>
        public ApiResponse< List<Finding> > FindingsGetDuplicateStatusWithHttpInfo (int? id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsGetDuplicateStatus");

            var localVarPath = "./findings/{id}/duplicate/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsGetDuplicateStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<Finding>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (List<Finding>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<Finding>)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>Task of List&lt;Finding&gt;</returns>
        public async System.Threading.Tasks.Task<List<Finding>> FindingsGetDuplicateStatusAsync (int? id)
        {
             ApiResponse<List<Finding>> localVarResponse = await FindingsGetDuplicateStatusAsyncWithHttpInfo(id);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>Task of ApiResponse (List&lt;Finding&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<Finding>>> FindingsGetDuplicateStatusAsyncWithHttpInfo (int? id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsGetDuplicateStatus");

            var localVarPath = "./findings/{id}/duplicate/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsGetDuplicateStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<Finding>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (List<Finding>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<Finding>)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="title"> (optional)</param>
        /// <param name="date"> (optional)</param>
        /// <param name="slaStartDate"> (optional)</param>
        /// <param name="cwe">Multiple values may be separated by commas. (optional)</param>
        /// <param name="cve"> (optional)</param>
        /// <param name="cvssv3"> (optional)</param>
        /// <param name="cvssv3Score"> (optional)</param>
        /// <param name="severity"> (optional)</param>
        /// <param name="description"> (optional)</param>
        /// <param name="mitigation"> (optional)</param>
        /// <param name="impact"> (optional)</param>
        /// <param name="stepsToReproduce"> (optional)</param>
        /// <param name="severityJustification"> (optional)</param>
        /// <param name="endpoints">Multiple values may be separated by commas. (optional)</param>
        /// <param name="references"> (optional)</param>
        /// <param name="test"> (optional)</param>
        /// <param name="active"> (optional)</param>
        /// <param name="verified"> (optional)</param>
        /// <param name="falseP"> (optional)</param>
        /// <param name="duplicate"> (optional)</param>
        /// <param name="duplicateFinding"> (optional)</param>
        /// <param name="outOfScope"> (optional)</param>
        /// <param name="riskAccepted"> (optional)</param>
        /// <param name="underReview"> (optional)</param>
        /// <param name="lastStatusUpdate"> (optional)</param>
        /// <param name="reviewRequestedBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="reviewers">Multiple values may be separated by commas. (optional)</param>
        /// <param name="underDefectReview"> (optional)</param>
        /// <param name="defectReviewRequestedBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="isMitigated"> (optional)</param>
        /// <param name="mitigated"> (optional)</param>
        /// <param name="mitigatedBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="reporter">Multiple values may be separated by commas. (optional)</param>
        /// <param name="numericalSeverity"> (optional)</param>
        /// <param name="lastReviewed"> (optional)</param>
        /// <param name="lastReviewedBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="lineNumber"> (optional)</param>
        /// <param name="sourcefilepath"> (optional)</param>
        /// <param name="param"> (optional)</param>
        /// <param name="payload"> (optional)</param>
        /// <param name="hashCode"> (optional)</param>
        /// <param name="filePath"> (optional)</param>
        /// <param name="componentName"> (optional)</param>
        /// <param name="componentVersion"> (optional)</param>
        /// <param name="foundBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="staticFinding"> (optional)</param>
        /// <param name="dynamicFinding"> (optional)</param>
        /// <param name="created"> (optional)</param>
        /// <param name="scannerConfidence">Multiple values may be separated by commas. (optional)</param>
        /// <param name="sonarqubeIssue">Multiple values may be separated by commas. (optional)</param>
        /// <param name="uniqueIdFromTool"> (optional)</param>
        /// <param name="vulnIdFromTool"> (optional)</param>
        /// <param name="sastSourceObject"> (optional)</param>
        /// <param name="sastSinkObject"> (optional)</param>
        /// <param name="sastSourceLine">Multiple values may be separated by commas. (optional)</param>
        /// <param name="sastSourceFilePath"> (optional)</param>
        /// <param name="nbOccurences">Multiple values may be separated by commas. (optional)</param>
        /// <param name="publishDate"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="stepToReproduce"> (optional)</param>
        /// <param name="sourcefile"> (optional)</param>
        /// <param name="jiraCreation"> (optional)</param>
        /// <param name="jiraChange"> (optional)</param>
        /// <param name="id">Multiple values may be separated by commas. (optional)</param>
        /// <param name="testTestType">Multiple values may be separated by commas. (optional)</param>
        /// <param name="testEngagement">Multiple values may be separated by commas. (optional)</param>
        /// <param name="testEngagementProduct">Multiple values may be separated by commas. (optional)</param>
        /// <param name="findingGroup">Multiple values may be separated by commas. (optional)</param>
        /// <param name="riskAcceptance"> (optional)</param>
        /// <param name="tag"> (optional)</param>
        /// <param name="o"> (optional)</param>
        /// <param name="limit">Number of results to return per page. (optional)</param>
        /// <param name="offset">The initial index from which to return the results. (optional)</param>
        /// <param name="prefetch"> (optional)</param>
        /// <param name="relatedFields">Expand finding external relations (engagement, environment, product, product_type, test, test_type) (optional)</param>
        /// <returns>InlineResponse2005</returns>
        public InlineResponse2005 FindingsList (string title = null, string date = null, string slaStartDate = null, decimal? cwe = null, string cve = null, string cvssv3 = null, decimal? cvssv3Score = null, string severity = null, string description = null, string mitigation = null, string impact = null, string stepsToReproduce = null, string severityJustification = null, decimal? endpoints = null, string references = null, string test = null, string active = null, string verified = null, string falseP = null, string duplicate = null, string duplicateFinding = null, string outOfScope = null, string riskAccepted = null, string underReview = null, string lastStatusUpdate = null, decimal? reviewRequestedBy = null, decimal? reviewers = null, string underDefectReview = null, decimal? defectReviewRequestedBy = null, string isMitigated = null, string mitigated = null, decimal? mitigatedBy = null, decimal? reporter = null, string numericalSeverity = null, string lastReviewed = null, decimal? lastReviewedBy = null, string lineNumber = null, string sourcefilepath = null, string param = null, string payload = null, string hashCode = null, string filePath = null, string componentName = null, string componentVersion = null, decimal? foundBy = null, string staticFinding = null, string dynamicFinding = null, string created = null, decimal? scannerConfidence = null, decimal? sonarqubeIssue = null, string uniqueIdFromTool = null, string vulnIdFromTool = null, string sastSourceObject = null, string sastSinkObject = null, decimal? sastSourceLine = null, string sastSourceFilePath = null, decimal? nbOccurences = null, string publishDate = null, string tags = null, string stepToReproduce = null, string sourcefile = null, string jiraCreation = null, string jiraChange = null, decimal? id = null, decimal? testTestType = null, decimal? testEngagement = null, decimal? testEngagementProduct = null, decimal? findingGroup = null, string riskAcceptance = null, string tag = null, string o = null, int? limit = null, int? offset = null, List<string> prefetch = null, bool? relatedFields = null)
        {
             ApiResponse<InlineResponse2005> localVarResponse = FindingsListWithHttpInfo(title, date, slaStartDate, cwe, cve, cvssv3, cvssv3Score, severity, description, mitigation, impact, stepsToReproduce, severityJustification, endpoints, references, test, active, verified, falseP, duplicate, duplicateFinding, outOfScope, riskAccepted, underReview, lastStatusUpdate, reviewRequestedBy, reviewers, underDefectReview, defectReviewRequestedBy, isMitigated, mitigated, mitigatedBy, reporter, numericalSeverity, lastReviewed, lastReviewedBy, lineNumber, sourcefilepath, param, payload, hashCode, filePath, componentName, componentVersion, foundBy, staticFinding, dynamicFinding, created, scannerConfidence, sonarqubeIssue, uniqueIdFromTool, vulnIdFromTool, sastSourceObject, sastSinkObject, sastSourceLine, sastSourceFilePath, nbOccurences, publishDate, tags, stepToReproduce, sourcefile, jiraCreation, jiraChange, id, testTestType, testEngagement, testEngagementProduct, findingGroup, riskAcceptance, tag, o, limit, offset, prefetch, relatedFields);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="title"> (optional)</param>
        /// <param name="date"> (optional)</param>
        /// <param name="slaStartDate"> (optional)</param>
        /// <param name="cwe">Multiple values may be separated by commas. (optional)</param>
        /// <param name="cve"> (optional)</param>
        /// <param name="cvssv3"> (optional)</param>
        /// <param name="cvssv3Score"> (optional)</param>
        /// <param name="severity"> (optional)</param>
        /// <param name="description"> (optional)</param>
        /// <param name="mitigation"> (optional)</param>
        /// <param name="impact"> (optional)</param>
        /// <param name="stepsToReproduce"> (optional)</param>
        /// <param name="severityJustification"> (optional)</param>
        /// <param name="endpoints">Multiple values may be separated by commas. (optional)</param>
        /// <param name="references"> (optional)</param>
        /// <param name="test"> (optional)</param>
        /// <param name="active"> (optional)</param>
        /// <param name="verified"> (optional)</param>
        /// <param name="falseP"> (optional)</param>
        /// <param name="duplicate"> (optional)</param>
        /// <param name="duplicateFinding"> (optional)</param>
        /// <param name="outOfScope"> (optional)</param>
        /// <param name="riskAccepted"> (optional)</param>
        /// <param name="underReview"> (optional)</param>
        /// <param name="lastStatusUpdate"> (optional)</param>
        /// <param name="reviewRequestedBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="reviewers">Multiple values may be separated by commas. (optional)</param>
        /// <param name="underDefectReview"> (optional)</param>
        /// <param name="defectReviewRequestedBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="isMitigated"> (optional)</param>
        /// <param name="mitigated"> (optional)</param>
        /// <param name="mitigatedBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="reporter">Multiple values may be separated by commas. (optional)</param>
        /// <param name="numericalSeverity"> (optional)</param>
        /// <param name="lastReviewed"> (optional)</param>
        /// <param name="lastReviewedBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="lineNumber"> (optional)</param>
        /// <param name="sourcefilepath"> (optional)</param>
        /// <param name="param"> (optional)</param>
        /// <param name="payload"> (optional)</param>
        /// <param name="hashCode"> (optional)</param>
        /// <param name="filePath"> (optional)</param>
        /// <param name="componentName"> (optional)</param>
        /// <param name="componentVersion"> (optional)</param>
        /// <param name="foundBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="staticFinding"> (optional)</param>
        /// <param name="dynamicFinding"> (optional)</param>
        /// <param name="created"> (optional)</param>
        /// <param name="scannerConfidence">Multiple values may be separated by commas. (optional)</param>
        /// <param name="sonarqubeIssue">Multiple values may be separated by commas. (optional)</param>
        /// <param name="uniqueIdFromTool"> (optional)</param>
        /// <param name="vulnIdFromTool"> (optional)</param>
        /// <param name="sastSourceObject"> (optional)</param>
        /// <param name="sastSinkObject"> (optional)</param>
        /// <param name="sastSourceLine">Multiple values may be separated by commas. (optional)</param>
        /// <param name="sastSourceFilePath"> (optional)</param>
        /// <param name="nbOccurences">Multiple values may be separated by commas. (optional)</param>
        /// <param name="publishDate"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="stepToReproduce"> (optional)</param>
        /// <param name="sourcefile"> (optional)</param>
        /// <param name="jiraCreation"> (optional)</param>
        /// <param name="jiraChange"> (optional)</param>
        /// <param name="id">Multiple values may be separated by commas. (optional)</param>
        /// <param name="testTestType">Multiple values may be separated by commas. (optional)</param>
        /// <param name="testEngagement">Multiple values may be separated by commas. (optional)</param>
        /// <param name="testEngagementProduct">Multiple values may be separated by commas. (optional)</param>
        /// <param name="findingGroup">Multiple values may be separated by commas. (optional)</param>
        /// <param name="riskAcceptance"> (optional)</param>
        /// <param name="tag"> (optional)</param>
        /// <param name="o"> (optional)</param>
        /// <param name="limit">Number of results to return per page. (optional)</param>
        /// <param name="offset">The initial index from which to return the results. (optional)</param>
        /// <param name="prefetch"> (optional)</param>
        /// <param name="relatedFields">Expand finding external relations (engagement, environment, product, product_type, test, test_type) (optional)</param>
        /// <returns>ApiResponse of InlineResponse2005</returns>
        public ApiResponse< InlineResponse2005 > FindingsListWithHttpInfo (string title = null, string date = null, string slaStartDate = null, decimal? cwe = null, string cve = null, string cvssv3 = null, decimal? cvssv3Score = null, string severity = null, string description = null, string mitigation = null, string impact = null, string stepsToReproduce = null, string severityJustification = null, decimal? endpoints = null, string references = null, string test = null, string active = null, string verified = null, string falseP = null, string duplicate = null, string duplicateFinding = null, string outOfScope = null, string riskAccepted = null, string underReview = null, string lastStatusUpdate = null, decimal? reviewRequestedBy = null, decimal? reviewers = null, string underDefectReview = null, decimal? defectReviewRequestedBy = null, string isMitigated = null, string mitigated = null, decimal? mitigatedBy = null, decimal? reporter = null, string numericalSeverity = null, string lastReviewed = null, decimal? lastReviewedBy = null, string lineNumber = null, string sourcefilepath = null, string param = null, string payload = null, string hashCode = null, string filePath = null, string componentName = null, string componentVersion = null, decimal? foundBy = null, string staticFinding = null, string dynamicFinding = null, string created = null, decimal? scannerConfidence = null, decimal? sonarqubeIssue = null, string uniqueIdFromTool = null, string vulnIdFromTool = null, string sastSourceObject = null, string sastSinkObject = null, decimal? sastSourceLine = null, string sastSourceFilePath = null, decimal? nbOccurences = null, string publishDate = null, string tags = null, string stepToReproduce = null, string sourcefile = null, string jiraCreation = null, string jiraChange = null, decimal? id = null, decimal? testTestType = null, decimal? testEngagement = null, decimal? testEngagementProduct = null, decimal? findingGroup = null, string riskAcceptance = null, string tag = null, string o = null, int? limit = null, int? offset = null, List<string> prefetch = null, bool? relatedFields = null)
        {

            var localVarPath = "./findings/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (title != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "title", title)); // query parameter
            if (date != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "date", date)); // query parameter
            if (slaStartDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "sla_start_date", slaStartDate)); // query parameter
            if (cwe != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "cwe", cwe)); // query parameter
            if (cve != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "cve", cve)); // query parameter
            if (cvssv3 != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "cvssv3", cvssv3)); // query parameter
            if (cvssv3Score != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "cvssv3_score", cvssv3Score)); // query parameter
            if (severity != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "severity", severity)); // query parameter
            if (description != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "description", description)); // query parameter
            if (mitigation != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "mitigation", mitigation)); // query parameter
            if (impact != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "impact", impact)); // query parameter
            if (stepsToReproduce != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "steps_to_reproduce", stepsToReproduce)); // query parameter
            if (severityJustification != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "severity_justification", severityJustification)); // query parameter
            if (endpoints != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "endpoints", endpoints)); // query parameter
            if (references != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "references", references)); // query parameter
            if (test != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "test", test)); // query parameter
            if (active != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "active", active)); // query parameter
            if (verified != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "verified", verified)); // query parameter
            if (falseP != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "false_p", falseP)); // query parameter
            if (duplicate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "duplicate", duplicate)); // query parameter
            if (duplicateFinding != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "duplicate_finding", duplicateFinding)); // query parameter
            if (outOfScope != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "out_of_scope", outOfScope)); // query parameter
            if (riskAccepted != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "risk_accepted", riskAccepted)); // query parameter
            if (underReview != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "under_review", underReview)); // query parameter
            if (lastStatusUpdate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "last_status_update", lastStatusUpdate)); // query parameter
            if (reviewRequestedBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "review_requested_by", reviewRequestedBy)); // query parameter
            if (reviewers != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "reviewers", reviewers)); // query parameter
            if (underDefectReview != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "under_defect_review", underDefectReview)); // query parameter
            if (defectReviewRequestedBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "defect_review_requested_by", defectReviewRequestedBy)); // query parameter
            if (isMitigated != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "is_Mitigated", isMitigated)); // query parameter
            if (mitigated != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "mitigated", mitigated)); // query parameter
            if (mitigatedBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "mitigated_by", mitigatedBy)); // query parameter
            if (reporter != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "reporter", reporter)); // query parameter
            if (numericalSeverity != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "numerical_severity", numericalSeverity)); // query parameter
            if (lastReviewed != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "last_reviewed", lastReviewed)); // query parameter
            if (lastReviewedBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "last_reviewed_by", lastReviewedBy)); // query parameter
            if (lineNumber != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "line_number", lineNumber)); // query parameter
            if (sourcefilepath != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "sourcefilepath", sourcefilepath)); // query parameter
            if (param != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "param", param)); // query parameter
            if (payload != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "payload", payload)); // query parameter
            if (hashCode != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "hash_code", hashCode)); // query parameter
            if (filePath != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "file_path", filePath)); // query parameter
            if (componentName != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "component_name", componentName)); // query parameter
            if (componentVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "component_version", componentVersion)); // query parameter
            if (foundBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "found_by", foundBy)); // query parameter
            if (staticFinding != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "static_finding", staticFinding)); // query parameter
            if (dynamicFinding != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "dynamic_finding", dynamicFinding)); // query parameter
            if (created != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "created", created)); // query parameter
            if (scannerConfidence != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "scanner_confidence", scannerConfidence)); // query parameter
            if (sonarqubeIssue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "sonarqube_issue", sonarqubeIssue)); // query parameter
            if (uniqueIdFromTool != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "unique_id_from_tool", uniqueIdFromTool)); // query parameter
            if (vulnIdFromTool != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "vuln_id_from_tool", vulnIdFromTool)); // query parameter
            if (sastSourceObject != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "sast_source_object", sastSourceObject)); // query parameter
            if (sastSinkObject != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "sast_sink_object", sastSinkObject)); // query parameter
            if (sastSourceLine != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "sast_source_line", sastSourceLine)); // query parameter
            if (sastSourceFilePath != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "sast_source_file_path", sastSourceFilePath)); // query parameter
            if (nbOccurences != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "nb_occurences", nbOccurences)); // query parameter
            if (publishDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "publish_date", publishDate)); // query parameter
            if (tags != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tags", tags)); // query parameter
            if (stepToReproduce != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "step_to_reproduce", stepToReproduce)); // query parameter
            if (sourcefile != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "sourcefile", sourcefile)); // query parameter
            if (jiraCreation != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "jira_creation", jiraCreation)); // query parameter
            if (jiraChange != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "jira_change", jiraChange)); // query parameter
            if (id != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "id", id)); // query parameter
            if (testTestType != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "test__test_type", testTestType)); // query parameter
            if (testEngagement != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "test__engagement", testEngagement)); // query parameter
            if (testEngagementProduct != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "test__engagement__product", testEngagementProduct)); // query parameter
            if (findingGroup != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "finding_group", findingGroup)); // query parameter
            if (riskAcceptance != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "risk_acceptance", riskAcceptance)); // query parameter
            if (tag != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tag", tag)); // query parameter
            if (o != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "o", o)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (offset != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "offset", offset)); // query parameter
            if (prefetch != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("csv", "prefetch", prefetch)); // query parameter
            if (relatedFields != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "related_fields", relatedFields)); // query parameter

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsList", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2005>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (InlineResponse2005) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2005)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="title"> (optional)</param>
        /// <param name="date"> (optional)</param>
        /// <param name="slaStartDate"> (optional)</param>
        /// <param name="cwe">Multiple values may be separated by commas. (optional)</param>
        /// <param name="cve"> (optional)</param>
        /// <param name="cvssv3"> (optional)</param>
        /// <param name="cvssv3Score"> (optional)</param>
        /// <param name="severity"> (optional)</param>
        /// <param name="description"> (optional)</param>
        /// <param name="mitigation"> (optional)</param>
        /// <param name="impact"> (optional)</param>
        /// <param name="stepsToReproduce"> (optional)</param>
        /// <param name="severityJustification"> (optional)</param>
        /// <param name="endpoints">Multiple values may be separated by commas. (optional)</param>
        /// <param name="references"> (optional)</param>
        /// <param name="test"> (optional)</param>
        /// <param name="active"> (optional)</param>
        /// <param name="verified"> (optional)</param>
        /// <param name="falseP"> (optional)</param>
        /// <param name="duplicate"> (optional)</param>
        /// <param name="duplicateFinding"> (optional)</param>
        /// <param name="outOfScope"> (optional)</param>
        /// <param name="riskAccepted"> (optional)</param>
        /// <param name="underReview"> (optional)</param>
        /// <param name="lastStatusUpdate"> (optional)</param>
        /// <param name="reviewRequestedBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="reviewers">Multiple values may be separated by commas. (optional)</param>
        /// <param name="underDefectReview"> (optional)</param>
        /// <param name="defectReviewRequestedBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="isMitigated"> (optional)</param>
        /// <param name="mitigated"> (optional)</param>
        /// <param name="mitigatedBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="reporter">Multiple values may be separated by commas. (optional)</param>
        /// <param name="numericalSeverity"> (optional)</param>
        /// <param name="lastReviewed"> (optional)</param>
        /// <param name="lastReviewedBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="lineNumber"> (optional)</param>
        /// <param name="sourcefilepath"> (optional)</param>
        /// <param name="param"> (optional)</param>
        /// <param name="payload"> (optional)</param>
        /// <param name="hashCode"> (optional)</param>
        /// <param name="filePath"> (optional)</param>
        /// <param name="componentName"> (optional)</param>
        /// <param name="componentVersion"> (optional)</param>
        /// <param name="foundBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="staticFinding"> (optional)</param>
        /// <param name="dynamicFinding"> (optional)</param>
        /// <param name="created"> (optional)</param>
        /// <param name="scannerConfidence">Multiple values may be separated by commas. (optional)</param>
        /// <param name="sonarqubeIssue">Multiple values may be separated by commas. (optional)</param>
        /// <param name="uniqueIdFromTool"> (optional)</param>
        /// <param name="vulnIdFromTool"> (optional)</param>
        /// <param name="sastSourceObject"> (optional)</param>
        /// <param name="sastSinkObject"> (optional)</param>
        /// <param name="sastSourceLine">Multiple values may be separated by commas. (optional)</param>
        /// <param name="sastSourceFilePath"> (optional)</param>
        /// <param name="nbOccurences">Multiple values may be separated by commas. (optional)</param>
        /// <param name="publishDate"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="stepToReproduce"> (optional)</param>
        /// <param name="sourcefile"> (optional)</param>
        /// <param name="jiraCreation"> (optional)</param>
        /// <param name="jiraChange"> (optional)</param>
        /// <param name="id">Multiple values may be separated by commas. (optional)</param>
        /// <param name="testTestType">Multiple values may be separated by commas. (optional)</param>
        /// <param name="testEngagement">Multiple values may be separated by commas. (optional)</param>
        /// <param name="testEngagementProduct">Multiple values may be separated by commas. (optional)</param>
        /// <param name="findingGroup">Multiple values may be separated by commas. (optional)</param>
        /// <param name="riskAcceptance"> (optional)</param>
        /// <param name="tag"> (optional)</param>
        /// <param name="o"> (optional)</param>
        /// <param name="limit">Number of results to return per page. (optional)</param>
        /// <param name="offset">The initial index from which to return the results. (optional)</param>
        /// <param name="prefetch"> (optional)</param>
        /// <param name="relatedFields">Expand finding external relations (engagement, environment, product, product_type, test, test_type) (optional)</param>
        /// <returns>Task of InlineResponse2005</returns>
        public async System.Threading.Tasks.Task<InlineResponse2005> FindingsListAsync (string title = null, string date = null, string slaStartDate = null, decimal? cwe = null, string cve = null, string cvssv3 = null, decimal? cvssv3Score = null, string severity = null, string description = null, string mitigation = null, string impact = null, string stepsToReproduce = null, string severityJustification = null, decimal? endpoints = null, string references = null, string test = null, string active = null, string verified = null, string falseP = null, string duplicate = null, string duplicateFinding = null, string outOfScope = null, string riskAccepted = null, string underReview = null, string lastStatusUpdate = null, decimal? reviewRequestedBy = null, decimal? reviewers = null, string underDefectReview = null, decimal? defectReviewRequestedBy = null, string isMitigated = null, string mitigated = null, decimal? mitigatedBy = null, decimal? reporter = null, string numericalSeverity = null, string lastReviewed = null, decimal? lastReviewedBy = null, string lineNumber = null, string sourcefilepath = null, string param = null, string payload = null, string hashCode = null, string filePath = null, string componentName = null, string componentVersion = null, decimal? foundBy = null, string staticFinding = null, string dynamicFinding = null, string created = null, decimal? scannerConfidence = null, decimal? sonarqubeIssue = null, string uniqueIdFromTool = null, string vulnIdFromTool = null, string sastSourceObject = null, string sastSinkObject = null, decimal? sastSourceLine = null, string sastSourceFilePath = null, decimal? nbOccurences = null, string publishDate = null, string tags = null, string stepToReproduce = null, string sourcefile = null, string jiraCreation = null, string jiraChange = null, decimal? id = null, decimal? testTestType = null, decimal? testEngagement = null, decimal? testEngagementProduct = null, decimal? findingGroup = null, string riskAcceptance = null, string tag = null, string o = null, int? limit = null, int? offset = null, List<string> prefetch = null, bool? relatedFields = null)
        {
             ApiResponse<InlineResponse2005> localVarResponse = await FindingsListAsyncWithHttpInfo(title, date, slaStartDate, cwe, cve, cvssv3, cvssv3Score, severity, description, mitigation, impact, stepsToReproduce, severityJustification, endpoints, references, test, active, verified, falseP, duplicate, duplicateFinding, outOfScope, riskAccepted, underReview, lastStatusUpdate, reviewRequestedBy, reviewers, underDefectReview, defectReviewRequestedBy, isMitigated, mitigated, mitigatedBy, reporter, numericalSeverity, lastReviewed, lastReviewedBy, lineNumber, sourcefilepath, param, payload, hashCode, filePath, componentName, componentVersion, foundBy, staticFinding, dynamicFinding, created, scannerConfidence, sonarqubeIssue, uniqueIdFromTool, vulnIdFromTool, sastSourceObject, sastSinkObject, sastSourceLine, sastSourceFilePath, nbOccurences, publishDate, tags, stepToReproduce, sourcefile, jiraCreation, jiraChange, id, testTestType, testEngagement, testEngagementProduct, findingGroup, riskAcceptance, tag, o, limit, offset, prefetch, relatedFields);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="title"> (optional)</param>
        /// <param name="date"> (optional)</param>
        /// <param name="slaStartDate"> (optional)</param>
        /// <param name="cwe">Multiple values may be separated by commas. (optional)</param>
        /// <param name="cve"> (optional)</param>
        /// <param name="cvssv3"> (optional)</param>
        /// <param name="cvssv3Score"> (optional)</param>
        /// <param name="severity"> (optional)</param>
        /// <param name="description"> (optional)</param>
        /// <param name="mitigation"> (optional)</param>
        /// <param name="impact"> (optional)</param>
        /// <param name="stepsToReproduce"> (optional)</param>
        /// <param name="severityJustification"> (optional)</param>
        /// <param name="endpoints">Multiple values may be separated by commas. (optional)</param>
        /// <param name="references"> (optional)</param>
        /// <param name="test"> (optional)</param>
        /// <param name="active"> (optional)</param>
        /// <param name="verified"> (optional)</param>
        /// <param name="falseP"> (optional)</param>
        /// <param name="duplicate"> (optional)</param>
        /// <param name="duplicateFinding"> (optional)</param>
        /// <param name="outOfScope"> (optional)</param>
        /// <param name="riskAccepted"> (optional)</param>
        /// <param name="underReview"> (optional)</param>
        /// <param name="lastStatusUpdate"> (optional)</param>
        /// <param name="reviewRequestedBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="reviewers">Multiple values may be separated by commas. (optional)</param>
        /// <param name="underDefectReview"> (optional)</param>
        /// <param name="defectReviewRequestedBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="isMitigated"> (optional)</param>
        /// <param name="mitigated"> (optional)</param>
        /// <param name="mitigatedBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="reporter">Multiple values may be separated by commas. (optional)</param>
        /// <param name="numericalSeverity"> (optional)</param>
        /// <param name="lastReviewed"> (optional)</param>
        /// <param name="lastReviewedBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="lineNumber"> (optional)</param>
        /// <param name="sourcefilepath"> (optional)</param>
        /// <param name="param"> (optional)</param>
        /// <param name="payload"> (optional)</param>
        /// <param name="hashCode"> (optional)</param>
        /// <param name="filePath"> (optional)</param>
        /// <param name="componentName"> (optional)</param>
        /// <param name="componentVersion"> (optional)</param>
        /// <param name="foundBy">Multiple values may be separated by commas. (optional)</param>
        /// <param name="staticFinding"> (optional)</param>
        /// <param name="dynamicFinding"> (optional)</param>
        /// <param name="created"> (optional)</param>
        /// <param name="scannerConfidence">Multiple values may be separated by commas. (optional)</param>
        /// <param name="sonarqubeIssue">Multiple values may be separated by commas. (optional)</param>
        /// <param name="uniqueIdFromTool"> (optional)</param>
        /// <param name="vulnIdFromTool"> (optional)</param>
        /// <param name="sastSourceObject"> (optional)</param>
        /// <param name="sastSinkObject"> (optional)</param>
        /// <param name="sastSourceLine">Multiple values may be separated by commas. (optional)</param>
        /// <param name="sastSourceFilePath"> (optional)</param>
        /// <param name="nbOccurences">Multiple values may be separated by commas. (optional)</param>
        /// <param name="publishDate"> (optional)</param>
        /// <param name="tags"> (optional)</param>
        /// <param name="stepToReproduce"> (optional)</param>
        /// <param name="sourcefile"> (optional)</param>
        /// <param name="jiraCreation"> (optional)</param>
        /// <param name="jiraChange"> (optional)</param>
        /// <param name="id">Multiple values may be separated by commas. (optional)</param>
        /// <param name="testTestType">Multiple values may be separated by commas. (optional)</param>
        /// <param name="testEngagement">Multiple values may be separated by commas. (optional)</param>
        /// <param name="testEngagementProduct">Multiple values may be separated by commas. (optional)</param>
        /// <param name="findingGroup">Multiple values may be separated by commas. (optional)</param>
        /// <param name="riskAcceptance"> (optional)</param>
        /// <param name="tag"> (optional)</param>
        /// <param name="o"> (optional)</param>
        /// <param name="limit">Number of results to return per page. (optional)</param>
        /// <param name="offset">The initial index from which to return the results. (optional)</param>
        /// <param name="prefetch"> (optional)</param>
        /// <param name="relatedFields">Expand finding external relations (engagement, environment, product, product_type, test, test_type) (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2005)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InlineResponse2005>> FindingsListAsyncWithHttpInfo (string title = null, string date = null, string slaStartDate = null, decimal? cwe = null, string cve = null, string cvssv3 = null, decimal? cvssv3Score = null, string severity = null, string description = null, string mitigation = null, string impact = null, string stepsToReproduce = null, string severityJustification = null, decimal? endpoints = null, string references = null, string test = null, string active = null, string verified = null, string falseP = null, string duplicate = null, string duplicateFinding = null, string outOfScope = null, string riskAccepted = null, string underReview = null, string lastStatusUpdate = null, decimal? reviewRequestedBy = null, decimal? reviewers = null, string underDefectReview = null, decimal? defectReviewRequestedBy = null, string isMitigated = null, string mitigated = null, decimal? mitigatedBy = null, decimal? reporter = null, string numericalSeverity = null, string lastReviewed = null, decimal? lastReviewedBy = null, string lineNumber = null, string sourcefilepath = null, string param = null, string payload = null, string hashCode = null, string filePath = null, string componentName = null, string componentVersion = null, decimal? foundBy = null, string staticFinding = null, string dynamicFinding = null, string created = null, decimal? scannerConfidence = null, decimal? sonarqubeIssue = null, string uniqueIdFromTool = null, string vulnIdFromTool = null, string sastSourceObject = null, string sastSinkObject = null, decimal? sastSourceLine = null, string sastSourceFilePath = null, decimal? nbOccurences = null, string publishDate = null, string tags = null, string stepToReproduce = null, string sourcefile = null, string jiraCreation = null, string jiraChange = null, decimal? id = null, decimal? testTestType = null, decimal? testEngagement = null, decimal? testEngagementProduct = null, decimal? findingGroup = null, string riskAcceptance = null, string tag = null, string o = null, int? limit = null, int? offset = null, List<string> prefetch = null, bool? relatedFields = null)
        {

            var localVarPath = "./findings/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (title != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "title", title)); // query parameter
            if (date != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "date", date)); // query parameter
            if (slaStartDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "sla_start_date", slaStartDate)); // query parameter
            if (cwe != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "cwe", cwe)); // query parameter
            if (cve != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "cve", cve)); // query parameter
            if (cvssv3 != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "cvssv3", cvssv3)); // query parameter
            if (cvssv3Score != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "cvssv3_score", cvssv3Score)); // query parameter
            if (severity != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "severity", severity)); // query parameter
            if (description != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "description", description)); // query parameter
            if (mitigation != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "mitigation", mitigation)); // query parameter
            if (impact != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "impact", impact)); // query parameter
            if (stepsToReproduce != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "steps_to_reproduce", stepsToReproduce)); // query parameter
            if (severityJustification != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "severity_justification", severityJustification)); // query parameter
            if (endpoints != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "endpoints", endpoints)); // query parameter
            if (references != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "references", references)); // query parameter
            if (test != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "test", test)); // query parameter
            if (active != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "active", active)); // query parameter
            if (verified != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "verified", verified)); // query parameter
            if (falseP != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "false_p", falseP)); // query parameter
            if (duplicate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "duplicate", duplicate)); // query parameter
            if (duplicateFinding != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "duplicate_finding", duplicateFinding)); // query parameter
            if (outOfScope != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "out_of_scope", outOfScope)); // query parameter
            if (riskAccepted != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "risk_accepted", riskAccepted)); // query parameter
            if (underReview != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "under_review", underReview)); // query parameter
            if (lastStatusUpdate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "last_status_update", lastStatusUpdate)); // query parameter
            if (reviewRequestedBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "review_requested_by", reviewRequestedBy)); // query parameter
            if (reviewers != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "reviewers", reviewers)); // query parameter
            if (underDefectReview != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "under_defect_review", underDefectReview)); // query parameter
            if (defectReviewRequestedBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "defect_review_requested_by", defectReviewRequestedBy)); // query parameter
            if (isMitigated != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "is_Mitigated", isMitigated)); // query parameter
            if (mitigated != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "mitigated", mitigated)); // query parameter
            if (mitigatedBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "mitigated_by", mitigatedBy)); // query parameter
            if (reporter != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "reporter", reporter)); // query parameter
            if (numericalSeverity != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "numerical_severity", numericalSeverity)); // query parameter
            if (lastReviewed != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "last_reviewed", lastReviewed)); // query parameter
            if (lastReviewedBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "last_reviewed_by", lastReviewedBy)); // query parameter
            if (lineNumber != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "line_number", lineNumber)); // query parameter
            if (sourcefilepath != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "sourcefilepath", sourcefilepath)); // query parameter
            if (param != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "param", param)); // query parameter
            if (payload != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "payload", payload)); // query parameter
            if (hashCode != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "hash_code", hashCode)); // query parameter
            if (filePath != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "file_path", filePath)); // query parameter
            if (componentName != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "component_name", componentName)); // query parameter
            if (componentVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "component_version", componentVersion)); // query parameter
            if (foundBy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "found_by", foundBy)); // query parameter
            if (staticFinding != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "static_finding", staticFinding)); // query parameter
            if (dynamicFinding != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "dynamic_finding", dynamicFinding)); // query parameter
            if (created != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "created", created)); // query parameter
            if (scannerConfidence != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "scanner_confidence", scannerConfidence)); // query parameter
            if (sonarqubeIssue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "sonarqube_issue", sonarqubeIssue)); // query parameter
            if (uniqueIdFromTool != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "unique_id_from_tool", uniqueIdFromTool)); // query parameter
            if (vulnIdFromTool != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "vuln_id_from_tool", vulnIdFromTool)); // query parameter
            if (sastSourceObject != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "sast_source_object", sastSourceObject)); // query parameter
            if (sastSinkObject != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "sast_sink_object", sastSinkObject)); // query parameter
            if (sastSourceLine != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "sast_source_line", sastSourceLine)); // query parameter
            if (sastSourceFilePath != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "sast_source_file_path", sastSourceFilePath)); // query parameter
            if (nbOccurences != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "nb_occurences", nbOccurences)); // query parameter
            if (publishDate != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "publish_date", publishDate)); // query parameter
            if (tags != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tags", tags)); // query parameter
            if (stepToReproduce != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "step_to_reproduce", stepToReproduce)); // query parameter
            if (sourcefile != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "sourcefile", sourcefile)); // query parameter
            if (jiraCreation != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "jira_creation", jiraCreation)); // query parameter
            if (jiraChange != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "jira_change", jiraChange)); // query parameter
            if (id != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "id", id)); // query parameter
            if (testTestType != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "test__test_type", testTestType)); // query parameter
            if (testEngagement != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "test__engagement", testEngagement)); // query parameter
            if (testEngagementProduct != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "test__engagement__product", testEngagementProduct)); // query parameter
            if (findingGroup != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "finding_group", findingGroup)); // query parameter
            if (riskAcceptance != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "risk_acceptance", riskAcceptance)); // query parameter
            if (tag != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "tag", tag)); // query parameter
            if (o != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "o", o)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (offset != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "offset", offset)); // query parameter
            if (prefetch != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("csv", "prefetch", prefetch)); // query parameter
            if (relatedFields != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "related_fields", relatedFields)); // query parameter

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsList", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2005>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (InlineResponse2005) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2005)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>FindingMeta</returns>
        public FindingMeta FindingsMetadataCreate (int? id, FindingMeta data)
        {
             ApiResponse<FindingMeta> localVarResponse = FindingsMetadataCreateWithHttpInfo(id, data);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>ApiResponse of FindingMeta</returns>
        public ApiResponse< FindingMeta > FindingsMetadataCreateWithHttpInfo (int? id, FindingMeta data)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsMetadataCreate");
            // verify the required parameter 'data' is set
            if (data == null)
                throw new ApiException(400, "Missing required parameter 'data' when calling FindingsApi->FindingsMetadataCreate");

            var localVarPath = "./findings/{id}/metadata/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (data != null && data.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(data); // http body (model) parameter
            }
            else
            {
                localVarPostBody = data; // byte array
            }

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsMetadataCreate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<FindingMeta>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (FindingMeta) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(FindingMeta)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of FindingMeta</returns>
        public async System.Threading.Tasks.Task<FindingMeta> FindingsMetadataCreateAsync (int? id, FindingMeta data)
        {
             ApiResponse<FindingMeta> localVarResponse = await FindingsMetadataCreateAsyncWithHttpInfo(id, data);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of ApiResponse (FindingMeta)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<FindingMeta>> FindingsMetadataCreateAsyncWithHttpInfo (int? id, FindingMeta data)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsMetadataCreate");
            // verify the required parameter 'data' is set
            if (data == null)
                throw new ApiException(400, "Missing required parameter 'data' when calling FindingsApi->FindingsMetadataCreate");

            var localVarPath = "./findings/{id}/metadata/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (data != null && data.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(data); // http body (model) parameter
            }
            else
            {
                localVarPostBody = data; // byte array
            }

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsMetadataCreate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<FindingMeta>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (FindingMeta) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(FindingMeta)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="name">name of the metadata to retrieve. If name is empty, return all the                             metadata associated with the finding</param>
        /// <returns></returns>
        public void FindingsMetadataDelete (int? id, string name)
        {
             FindingsMetadataDeleteWithHttpInfo(id, name);
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="name">name of the metadata to retrieve. If name is empty, return all the                             metadata associated with the finding</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> FindingsMetadataDeleteWithHttpInfo (int? id, string name)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsMetadataDelete");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling FindingsApi->FindingsMetadataDelete");

            var localVarPath = "./findings/{id}/metadata/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsMetadataDelete", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="name">name of the metadata to retrieve. If name is empty, return all the                             metadata associated with the finding</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task FindingsMetadataDeleteAsync (int? id, string name)
        {
             await FindingsMetadataDeleteAsyncWithHttpInfo(id, name);

        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="name">name of the metadata to retrieve. If name is empty, return all the                             metadata associated with the finding</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> FindingsMetadataDeleteAsyncWithHttpInfo (int? id, string name)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsMetadataDelete");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling FindingsApi->FindingsMetadataDelete");

            var localVarPath = "./findings/{id}/metadata/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsMetadataDelete", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>List&lt;FindingMeta&gt;</returns>
        public List<FindingMeta> FindingsMetadataRead (int? id)
        {
             ApiResponse<List<FindingMeta>> localVarResponse = FindingsMetadataReadWithHttpInfo(id);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>ApiResponse of List&lt;FindingMeta&gt;</returns>
        public ApiResponse< List<FindingMeta> > FindingsMetadataReadWithHttpInfo (int? id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsMetadataRead");

            var localVarPath = "./findings/{id}/metadata/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsMetadataRead", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<FindingMeta>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (List<FindingMeta>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<FindingMeta>)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>Task of List&lt;FindingMeta&gt;</returns>
        public async System.Threading.Tasks.Task<List<FindingMeta>> FindingsMetadataReadAsync (int? id)
        {
             ApiResponse<List<FindingMeta>> localVarResponse = await FindingsMetadataReadAsyncWithHttpInfo(id);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>Task of ApiResponse (List&lt;FindingMeta&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<FindingMeta>>> FindingsMetadataReadAsyncWithHttpInfo (int? id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsMetadataRead");

            var localVarPath = "./findings/{id}/metadata/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsMetadataRead", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<FindingMeta>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (List<FindingMeta>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<FindingMeta>)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <param name="name">name of the metadata to edit</param>
        /// <returns>FindingMeta</returns>
        public FindingMeta FindingsMetadataUpdate (int? id, FindingMeta data, string name)
        {
             ApiResponse<FindingMeta> localVarResponse = FindingsMetadataUpdateWithHttpInfo(id, data, name);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <param name="name">name of the metadata to edit</param>
        /// <returns>ApiResponse of FindingMeta</returns>
        public ApiResponse< FindingMeta > FindingsMetadataUpdateWithHttpInfo (int? id, FindingMeta data, string name)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsMetadataUpdate");
            // verify the required parameter 'data' is set
            if (data == null)
                throw new ApiException(400, "Missing required parameter 'data' when calling FindingsApi->FindingsMetadataUpdate");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling FindingsApi->FindingsMetadataUpdate");

            var localVarPath = "./findings/{id}/metadata/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter
            if (data != null && data.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(data); // http body (model) parameter
            }
            else
            {
                localVarPostBody = data; // byte array
            }

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsMetadataUpdate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<FindingMeta>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (FindingMeta) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(FindingMeta)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <param name="name">name of the metadata to edit</param>
        /// <returns>Task of FindingMeta</returns>
        public async System.Threading.Tasks.Task<FindingMeta> FindingsMetadataUpdateAsync (int? id, FindingMeta data, string name)
        {
             ApiResponse<FindingMeta> localVarResponse = await FindingsMetadataUpdateAsyncWithHttpInfo(id, data, name);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <param name="name">name of the metadata to edit</param>
        /// <returns>Task of ApiResponse (FindingMeta)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<FindingMeta>> FindingsMetadataUpdateAsyncWithHttpInfo (int? id, FindingMeta data, string name)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsMetadataUpdate");
            // verify the required parameter 'data' is set
            if (data == null)
                throw new ApiException(400, "Missing required parameter 'data' when calling FindingsApi->FindingsMetadataUpdate");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling FindingsApi->FindingsMetadataUpdate");

            var localVarPath = "./findings/{id}/metadata/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "name", name)); // query parameter
            if (data != null && data.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(data); // http body (model) parameter
            }
            else
            {
                localVarPostBody = data; // byte array
            }

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsMetadataUpdate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<FindingMeta>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (FindingMeta) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(FindingMeta)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Note</returns>
        public Note FindingsNotesCreate (int? id, AddNewNoteOption data)
        {
             ApiResponse<Note> localVarResponse = FindingsNotesCreateWithHttpInfo(id, data);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>ApiResponse of Note</returns>
        public ApiResponse< Note > FindingsNotesCreateWithHttpInfo (int? id, AddNewNoteOption data)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsNotesCreate");
            // verify the required parameter 'data' is set
            if (data == null)
                throw new ApiException(400, "Missing required parameter 'data' when calling FindingsApi->FindingsNotesCreate");

            var localVarPath = "./findings/{id}/notes/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (data != null && data.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(data); // http body (model) parameter
            }
            else
            {
                localVarPostBody = data; // byte array
            }

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsNotesCreate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Note>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (Note) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Note)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of Note</returns>
        public async System.Threading.Tasks.Task<Note> FindingsNotesCreateAsync (int? id, AddNewNoteOption data)
        {
             ApiResponse<Note> localVarResponse = await FindingsNotesCreateAsyncWithHttpInfo(id, data);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of ApiResponse (Note)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Note>> FindingsNotesCreateAsyncWithHttpInfo (int? id, AddNewNoteOption data)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsNotesCreate");
            // verify the required parameter 'data' is set
            if (data == null)
                throw new ApiException(400, "Missing required parameter 'data' when calling FindingsApi->FindingsNotesCreate");

            var localVarPath = "./findings/{id}/notes/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (data != null && data.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(data); // http body (model) parameter
            }
            else
            {
                localVarPostBody = data; // byte array
            }

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsNotesCreate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Note>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (Note) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Note)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Note</returns>
        public Note FindingsNotesPartialUpdate (int? id, AddNewNoteOption data)
        {
             ApiResponse<Note> localVarResponse = FindingsNotesPartialUpdateWithHttpInfo(id, data);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>ApiResponse of Note</returns>
        public ApiResponse< Note > FindingsNotesPartialUpdateWithHttpInfo (int? id, AddNewNoteOption data)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsNotesPartialUpdate");
            // verify the required parameter 'data' is set
            if (data == null)
                throw new ApiException(400, "Missing required parameter 'data' when calling FindingsApi->FindingsNotesPartialUpdate");

            var localVarPath = "./findings/{id}/notes/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (data != null && data.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(data); // http body (model) parameter
            }
            else
            {
                localVarPostBody = data; // byte array
            }

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsNotesPartialUpdate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Note>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (Note) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Note)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of Note</returns>
        public async System.Threading.Tasks.Task<Note> FindingsNotesPartialUpdateAsync (int? id, AddNewNoteOption data)
        {
             ApiResponse<Note> localVarResponse = await FindingsNotesPartialUpdateAsyncWithHttpInfo(id, data);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of ApiResponse (Note)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Note>> FindingsNotesPartialUpdateAsyncWithHttpInfo (int? id, AddNewNoteOption data)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsNotesPartialUpdate");
            // verify the required parameter 'data' is set
            if (data == null)
                throw new ApiException(400, "Missing required parameter 'data' when calling FindingsApi->FindingsNotesPartialUpdate");

            var localVarPath = "./findings/{id}/notes/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (data != null && data.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(data); // http body (model) parameter
            }
            else
            {
                localVarPostBody = data; // byte array
            }

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsNotesPartialUpdate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Note>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (Note) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Note)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>FindingToNotes</returns>
        public FindingToNotes FindingsNotesRead (int? id)
        {
             ApiResponse<FindingToNotes> localVarResponse = FindingsNotesReadWithHttpInfo(id);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>ApiResponse of FindingToNotes</returns>
        public ApiResponse< FindingToNotes > FindingsNotesReadWithHttpInfo (int? id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsNotesRead");

            var localVarPath = "./findings/{id}/notes/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsNotesRead", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<FindingToNotes>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (FindingToNotes) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(FindingToNotes)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>Task of FindingToNotes</returns>
        public async System.Threading.Tasks.Task<FindingToNotes> FindingsNotesReadAsync (int? id)
        {
             ApiResponse<FindingToNotes> localVarResponse = await FindingsNotesReadAsyncWithHttpInfo(id);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>Task of ApiResponse (FindingToNotes)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<FindingToNotes>> FindingsNotesReadAsyncWithHttpInfo (int? id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsNotesRead");

            var localVarPath = "./findings/{id}/notes/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsNotesRead", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<FindingToNotes>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (FindingToNotes) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(FindingToNotes)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Finding</returns>
        public Finding FindingsPartialUpdate (int? id, Finding data)
        {
             ApiResponse<Finding> localVarResponse = FindingsPartialUpdateWithHttpInfo(id, data);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>ApiResponse of Finding</returns>
        public ApiResponse< Finding > FindingsPartialUpdateWithHttpInfo (int? id, Finding data)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsPartialUpdate");
            // verify the required parameter 'data' is set
            if (data == null)
                throw new ApiException(400, "Missing required parameter 'data' when calling FindingsApi->FindingsPartialUpdate");

            var localVarPath = "./findings/{id}/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (data != null && data.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(data); // http body (model) parameter
            }
            else
            {
                localVarPostBody = data; // byte array
            }

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsPartialUpdate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Finding>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (Finding) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Finding)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of Finding</returns>
        public async System.Threading.Tasks.Task<Finding> FindingsPartialUpdateAsync (int? id, Finding data)
        {
             ApiResponse<Finding> localVarResponse = await FindingsPartialUpdateAsyncWithHttpInfo(id, data);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of ApiResponse (Finding)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Finding>> FindingsPartialUpdateAsyncWithHttpInfo (int? id, Finding data)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsPartialUpdate");
            // verify the required parameter 'data' is set
            if (data == null)
                throw new ApiException(400, "Missing required parameter 'data' when calling FindingsApi->FindingsPartialUpdate");

            var localVarPath = "./findings/{id}/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (data != null && data.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(data); // http body (model) parameter
            }
            else
            {
                localVarPostBody = data; // byte array
            }

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsPartialUpdate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Finding>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (Finding) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Finding)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="prefetch"> (optional)</param>
        /// <param name="relatedFields">Expand finding external relations (engagement, environment, product, product_type, test, test_type) (optional)</param>
        /// <returns>InlineResponse2006</returns>
        public InlineResponse2006 FindingsRead (int? id, List<string> prefetch = null, bool? relatedFields = null)
        {
             ApiResponse<InlineResponse2006> localVarResponse = FindingsReadWithHttpInfo(id, prefetch, relatedFields);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="prefetch"> (optional)</param>
        /// <param name="relatedFields">Expand finding external relations (engagement, environment, product, product_type, test, test_type) (optional)</param>
        /// <returns>ApiResponse of InlineResponse2006</returns>
        public ApiResponse< InlineResponse2006 > FindingsReadWithHttpInfo (int? id, List<string> prefetch = null, bool? relatedFields = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsRead");

            var localVarPath = "./findings/{id}/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (prefetch != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("csv", "prefetch", prefetch)); // query parameter
            if (relatedFields != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "related_fields", relatedFields)); // query parameter

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsRead", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2006>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (InlineResponse2006) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2006)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="prefetch"> (optional)</param>
        /// <param name="relatedFields">Expand finding external relations (engagement, environment, product, product_type, test, test_type) (optional)</param>
        /// <returns>Task of InlineResponse2006</returns>
        public async System.Threading.Tasks.Task<InlineResponse2006> FindingsReadAsync (int? id, List<string> prefetch = null, bool? relatedFields = null)
        {
             ApiResponse<InlineResponse2006> localVarResponse = await FindingsReadAsyncWithHttpInfo(id, prefetch, relatedFields);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="prefetch"> (optional)</param>
        /// <param name="relatedFields">Expand finding external relations (engagement, environment, product, product_type, test, test_type) (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2006)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InlineResponse2006>> FindingsReadAsyncWithHttpInfo (int? id, List<string> prefetch = null, bool? relatedFields = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsRead");

            var localVarPath = "./findings/{id}/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (prefetch != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("csv", "prefetch", prefetch)); // query parameter
            if (relatedFields != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "related_fields", relatedFields)); // query parameter

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsRead", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2006>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (InlineResponse2006) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2006)));
        }

        /// <summary>
        ///  Remove Note From Finding Note
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns></returns>
        public void FindingsRemoveNote (int? id, FindingNote data)
        {
             FindingsRemoveNoteWithHttpInfo(id, data);
        }

        /// <summary>
        ///  Remove Note From Finding Note
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> FindingsRemoveNoteWithHttpInfo (int? id, FindingNote data)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsRemoveNote");
            // verify the required parameter 'data' is set
            if (data == null)
                throw new ApiException(400, "Missing required parameter 'data' when calling FindingsApi->FindingsRemoveNote");

            var localVarPath = "./findings/{id}/remove_note/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (data != null && data.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(data); // http body (model) parameter
            }
            else
            {
                localVarPostBody = data; // byte array
            }

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsRemoveNote", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        ///  Remove Note From Finding Note
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task FindingsRemoveNoteAsync (int? id, FindingNote data)
        {
             await FindingsRemoveNoteAsyncWithHttpInfo(id, data);

        }

        /// <summary>
        ///  Remove Note From Finding Note
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> FindingsRemoveNoteAsyncWithHttpInfo (int? id, FindingNote data)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsRemoveNote");
            // verify the required parameter 'data' is set
            if (data == null)
                throw new ApiException(400, "Missing required parameter 'data' when calling FindingsApi->FindingsRemoveNote");

            var localVarPath = "./findings/{id}/remove_note/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (data != null && data.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(data); // http body (model) parameter
            }
            else
            {
                localVarPostBody = data; // byte array
            }

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsRemoveNote", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        ///  Remove Tag(s) from finding list of tags
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns></returns>
        public void FindingsRemoveTagsPartialUpdate (int? id, Tag data)
        {
             FindingsRemoveTagsPartialUpdateWithHttpInfo(id, data);
        }

        /// <summary>
        ///  Remove Tag(s) from finding list of tags
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> FindingsRemoveTagsPartialUpdateWithHttpInfo (int? id, Tag data)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsRemoveTagsPartialUpdate");
            // verify the required parameter 'data' is set
            if (data == null)
                throw new ApiException(400, "Missing required parameter 'data' when calling FindingsApi->FindingsRemoveTagsPartialUpdate");

            var localVarPath = "./findings/{id}/remove_tags/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (data != null && data.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(data); // http body (model) parameter
            }
            else
            {
                localVarPostBody = data; // byte array
            }

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsRemoveTagsPartialUpdate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        ///  Remove Tag(s) from finding list of tags
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task FindingsRemoveTagsPartialUpdateAsync (int? id, Tag data)
        {
             await FindingsRemoveTagsPartialUpdateAsyncWithHttpInfo(id, data);

        }

        /// <summary>
        ///  Remove Tag(s) from finding list of tags
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> FindingsRemoveTagsPartialUpdateAsyncWithHttpInfo (int? id, Tag data)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsRemoveTagsPartialUpdate");
            // verify the required parameter 'data' is set
            if (data == null)
                throw new ApiException(400, "Missing required parameter 'data' when calling FindingsApi->FindingsRemoveTagsPartialUpdate");

            var localVarPath = "./findings/{id}/remove_tags/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (data != null && data.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(data); // http body (model) parameter
            }
            else
            {
                localVarPostBody = data; // byte array
            }

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsRemoveTagsPartialUpdate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        ///  Remove Tag(s) from finding list of tags
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns></returns>
        public void FindingsRemoveTagsUpdate (int? id, Tag data)
        {
             FindingsRemoveTagsUpdateWithHttpInfo(id, data);
        }

        /// <summary>
        ///  Remove Tag(s) from finding list of tags
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> FindingsRemoveTagsUpdateWithHttpInfo (int? id, Tag data)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsRemoveTagsUpdate");
            // verify the required parameter 'data' is set
            if (data == null)
                throw new ApiException(400, "Missing required parameter 'data' when calling FindingsApi->FindingsRemoveTagsUpdate");

            var localVarPath = "./findings/{id}/remove_tags/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (data != null && data.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(data); // http body (model) parameter
            }
            else
            {
                localVarPostBody = data; // byte array
            }

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsRemoveTagsUpdate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        ///  Remove Tag(s) from finding list of tags
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task FindingsRemoveTagsUpdateAsync (int? id, Tag data)
        {
             await FindingsRemoveTagsUpdateAsyncWithHttpInfo(id, data);

        }

        /// <summary>
        ///  Remove Tag(s) from finding list of tags
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> FindingsRemoveTagsUpdateAsyncWithHttpInfo (int? id, Tag data)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsRemoveTagsUpdate");
            // verify the required parameter 'data' is set
            if (data == null)
                throw new ApiException(400, "Missing required parameter 'data' when calling FindingsApi->FindingsRemoveTagsUpdate");

            var localVarPath = "./findings/{id}/remove_tags/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (data != null && data.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(data); // http body (model) parameter
            }
            else
            {
                localVarPostBody = data; // byte array
            }

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsRemoveTagsUpdate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>BurpRawRequestResponse</returns>
        public BurpRawRequestResponse FindingsRequestResponseCreate (int? id, BurpRawRequestResponse data)
        {
             ApiResponse<BurpRawRequestResponse> localVarResponse = FindingsRequestResponseCreateWithHttpInfo(id, data);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>ApiResponse of BurpRawRequestResponse</returns>
        public ApiResponse< BurpRawRequestResponse > FindingsRequestResponseCreateWithHttpInfo (int? id, BurpRawRequestResponse data)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsRequestResponseCreate");
            // verify the required parameter 'data' is set
            if (data == null)
                throw new ApiException(400, "Missing required parameter 'data' when calling FindingsApi->FindingsRequestResponseCreate");

            var localVarPath = "./findings/{id}/request_response/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (data != null && data.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(data); // http body (model) parameter
            }
            else
            {
                localVarPostBody = data; // byte array
            }

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsRequestResponseCreate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<BurpRawRequestResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (BurpRawRequestResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(BurpRawRequestResponse)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of BurpRawRequestResponse</returns>
        public async System.Threading.Tasks.Task<BurpRawRequestResponse> FindingsRequestResponseCreateAsync (int? id, BurpRawRequestResponse data)
        {
             ApiResponse<BurpRawRequestResponse> localVarResponse = await FindingsRequestResponseCreateAsyncWithHttpInfo(id, data);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of ApiResponse (BurpRawRequestResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<BurpRawRequestResponse>> FindingsRequestResponseCreateAsyncWithHttpInfo (int? id, BurpRawRequestResponse data)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsRequestResponseCreate");
            // verify the required parameter 'data' is set
            if (data == null)
                throw new ApiException(400, "Missing required parameter 'data' when calling FindingsApi->FindingsRequestResponseCreate");

            var localVarPath = "./findings/{id}/request_response/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (data != null && data.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(data); // http body (model) parameter
            }
            else
            {
                localVarPostBody = data; // byte array
            }

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsRequestResponseCreate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<BurpRawRequestResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (BurpRawRequestResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(BurpRawRequestResponse)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>BurpRawRequestResponse</returns>
        public BurpRawRequestResponse FindingsRequestResponseRead (int? id)
        {
             ApiResponse<BurpRawRequestResponse> localVarResponse = FindingsRequestResponseReadWithHttpInfo(id);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>ApiResponse of BurpRawRequestResponse</returns>
        public ApiResponse< BurpRawRequestResponse > FindingsRequestResponseReadWithHttpInfo (int? id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsRequestResponseRead");

            var localVarPath = "./findings/{id}/request_response/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsRequestResponseRead", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<BurpRawRequestResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (BurpRawRequestResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(BurpRawRequestResponse)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>Task of BurpRawRequestResponse</returns>
        public async System.Threading.Tasks.Task<BurpRawRequestResponse> FindingsRequestResponseReadAsync (int? id)
        {
             ApiResponse<BurpRawRequestResponse> localVarResponse = await FindingsRequestResponseReadAsyncWithHttpInfo(id);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>Task of ApiResponse (BurpRawRequestResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<BurpRawRequestResponse>> FindingsRequestResponseReadAsyncWithHttpInfo (int? id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsRequestResponseRead");

            var localVarPath = "./findings/{id}/request_response/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsRequestResponseRead", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<BurpRawRequestResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (BurpRawRequestResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(BurpRawRequestResponse)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="newFid"></param>
        /// <returns></returns>
        public void FindingsSetFindingAsOriginal (int? id, string newFid)
        {
             FindingsSetFindingAsOriginalWithHttpInfo(id, newFid);
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="newFid"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> FindingsSetFindingAsOriginalWithHttpInfo (int? id, string newFid)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsSetFindingAsOriginal");
            // verify the required parameter 'newFid' is set
            if (newFid == null)
                throw new ApiException(400, "Missing required parameter 'newFid' when calling FindingsApi->FindingsSetFindingAsOriginal");

            var localVarPath = "./findings/{id}/original/{new_fid}/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (newFid != null) localVarPathParams.Add("new_fid", this.Configuration.ApiClient.ParameterToString(newFid)); // path parameter

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsSetFindingAsOriginal", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="newFid"></param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task FindingsSetFindingAsOriginalAsync (int? id, string newFid)
        {
             await FindingsSetFindingAsOriginalAsyncWithHttpInfo(id, newFid);

        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="newFid"></param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> FindingsSetFindingAsOriginalAsyncWithHttpInfo (int? id, string newFid)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsSetFindingAsOriginal");
            // verify the required parameter 'newFid' is set
            if (newFid == null)
                throw new ApiException(400, "Missing required parameter 'newFid' when calling FindingsApi->FindingsSetFindingAsOriginal");

            var localVarPath = "./findings/{id}/original/{new_fid}/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (newFid != null) localVarPathParams.Add("new_fid", this.Configuration.ApiClient.ParameterToString(newFid)); // path parameter

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsSetFindingAsOriginal", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Tag</returns>
        public Tag FindingsTagsCreate (int? id, Tag data)
        {
             ApiResponse<Tag> localVarResponse = FindingsTagsCreateWithHttpInfo(id, data);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>ApiResponse of Tag</returns>
        public ApiResponse< Tag > FindingsTagsCreateWithHttpInfo (int? id, Tag data)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsTagsCreate");
            // verify the required parameter 'data' is set
            if (data == null)
                throw new ApiException(400, "Missing required parameter 'data' when calling FindingsApi->FindingsTagsCreate");

            var localVarPath = "./findings/{id}/tags/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (data != null && data.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(data); // http body (model) parameter
            }
            else
            {
                localVarPostBody = data; // byte array
            }

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsTagsCreate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Tag>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (Tag) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Tag)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of Tag</returns>
        public async System.Threading.Tasks.Task<Tag> FindingsTagsCreateAsync (int? id, Tag data)
        {
             ApiResponse<Tag> localVarResponse = await FindingsTagsCreateAsyncWithHttpInfo(id, data);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of ApiResponse (Tag)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Tag>> FindingsTagsCreateAsyncWithHttpInfo (int? id, Tag data)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsTagsCreate");
            // verify the required parameter 'data' is set
            if (data == null)
                throw new ApiException(400, "Missing required parameter 'data' when calling FindingsApi->FindingsTagsCreate");

            var localVarPath = "./findings/{id}/tags/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (data != null && data.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(data); // http body (model) parameter
            }
            else
            {
                localVarPostBody = data; // byte array
            }

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsTagsCreate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Tag>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (Tag) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Tag)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>Tag</returns>
        public Tag FindingsTagsRead (int? id)
        {
             ApiResponse<Tag> localVarResponse = FindingsTagsReadWithHttpInfo(id);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>ApiResponse of Tag</returns>
        public ApiResponse< Tag > FindingsTagsReadWithHttpInfo (int? id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsTagsRead");

            var localVarPath = "./findings/{id}/tags/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsTagsRead", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Tag>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (Tag) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Tag)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>Task of Tag</returns>
        public async System.Threading.Tasks.Task<Tag> FindingsTagsReadAsync (int? id)
        {
             ApiResponse<Tag> localVarResponse = await FindingsTagsReadAsyncWithHttpInfo(id);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <returns>Task of ApiResponse (Tag)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Tag>> FindingsTagsReadAsyncWithHttpInfo (int? id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsTagsRead");

            var localVarPath = "./findings/{id}/tags/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsTagsRead", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Tag>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (Tag) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Tag)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Finding</returns>
        public Finding FindingsUpdate (int? id, Finding data)
        {
             ApiResponse<Finding> localVarResponse = FindingsUpdateWithHttpInfo(id, data);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>ApiResponse of Finding</returns>
        public ApiResponse< Finding > FindingsUpdateWithHttpInfo (int? id, Finding data)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsUpdate");
            // verify the required parameter 'data' is set
            if (data == null)
                throw new ApiException(400, "Missing required parameter 'data' when calling FindingsApi->FindingsUpdate");

            var localVarPath = "./findings/{id}/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (data != null && data.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(data); // http body (model) parameter
            }
            else
            {
                localVarPostBody = data; // byte array
            }

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsUpdate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Finding>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (Finding) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Finding)));
        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of Finding</returns>
        public async System.Threading.Tasks.Task<Finding> FindingsUpdateAsync (int? id, Finding data)
        {
             ApiResponse<Finding> localVarResponse = await FindingsUpdateAsyncWithHttpInfo(id, data);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  
        /// </summary>
        /// <exception cref="DefectDojo.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">A unique integer value identifying this finding.</param>
        /// <param name="data"></param>
        /// <returns>Task of ApiResponse (Finding)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Finding>> FindingsUpdateAsyncWithHttpInfo (int? id, Finding data)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling FindingsApi->FindingsUpdate");
            // verify the required parameter 'data' is set
            if (data == null)
                throw new ApiException(400, "Missing required parameter 'data' when calling FindingsApi->FindingsUpdate");

            var localVarPath = "./findings/{id}/";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (data != null && data.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(data); // http body (model) parameter
            }
            else
            {
                localVarPostBody = data; // byte array
            }

            // authentication (api_key) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("Authorization")))
            {
                localVarHeaderParams["Authorization"] = this.Configuration.GetApiKeyWithPrefix("Authorization");
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("FindingsUpdate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Finding>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Key, x => x.Value.ToString()),
                (Finding) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Finding)));
        }

    }
}
